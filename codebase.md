# .aidigestignore

```
.idea/
.dart_tool/
android/
ios/
build/
web/
linux/
macos/
windows/
```

# .firebaserc

```
{
  "projects": {
    "default": "listsapplication"
  }
}

```

# .flutter-plugins

```
# This is a generated file; do not edit or check into version control.
cloud_firestore=/Users/mika/.pub-cache/hosted/pub.dev/cloud_firestore-5.4.4/
cloud_firestore_web=/Users/mika/.pub-cache/hosted/pub.dev/cloud_firestore_web-4.3.2/
firebase_auth=/Users/mika/.pub-cache/hosted/pub.dev/firebase_auth-5.3.1/
firebase_auth_web=/Users/mika/.pub-cache/hosted/pub.dev/firebase_auth_web-5.13.2/
firebase_core=/Users/mika/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/
firebase_core_web=/Users/mika/.pub-cache/hosted/pub.dev/firebase_core_web-2.18.1/
path_provider=/Users/mika/.pub-cache/hosted/pub.dev/path_provider-2.1.4/
path_provider_android=/Users/mika/.pub-cache/hosted/pub.dev/path_provider_android-2.2.12/
path_provider_foundation=/Users/mika/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/
path_provider_linux=/Users/mika/.pub-cache/hosted/pub.dev/path_provider_linux-2.2.1/
path_provider_windows=/Users/mika/.pub-cache/hosted/pub.dev/path_provider_windows-2.3.0/
shared_preferences=/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences-2.3.2/
shared_preferences_android=/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_android-2.3.3/
shared_preferences_foundation=/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/
shared_preferences_linux=/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_linux-2.4.1/
shared_preferences_web=/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_web-2.4.2/
shared_preferences_windows=/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_windows-2.4.1/
url_launcher=/Users/mika/.pub-cache/hosted/pub.dev/url_launcher-6.3.1/
url_launcher_android=/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_android-6.3.13/
url_launcher_ios=/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_ios-6.3.1/
url_launcher_linux=/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_linux-3.2.0/
url_launcher_macos=/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_macos-3.2.1/
url_launcher_web=/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_web-2.3.3/
url_launcher_windows=/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_windows-3.1.3/

```

# .flutter-plugins-dependencies

```
{"info":"This is a generated file; do not edit or check into version control.","plugins":{"ios":[{"name":"cloud_firestore","path":"/Users/mika/.pub-cache/hosted/pub.dev/cloud_firestore-5.4.4/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_auth","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_auth-5.3.1/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_core","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/","native_build":true,"dependencies":[]},{"name":"path_provider_foundation","path":"/Users/mika/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"shared_preferences_foundation","path":"/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"url_launcher_ios","path":"/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_ios-6.3.1/","native_build":true,"dependencies":[]}],"android":[{"name":"cloud_firestore","path":"/Users/mika/.pub-cache/hosted/pub.dev/cloud_firestore-5.4.4/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_auth","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_auth-5.3.1/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_core","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/","native_build":true,"dependencies":[]},{"name":"path_provider_android","path":"/Users/mika/.pub-cache/hosted/pub.dev/path_provider_android-2.2.12/","native_build":true,"dependencies":[]},{"name":"shared_preferences_android","path":"/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_android-2.3.3/","native_build":true,"dependencies":[]},{"name":"url_launcher_android","path":"/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_android-6.3.13/","native_build":true,"dependencies":[]}],"macos":[{"name":"cloud_firestore","path":"/Users/mika/.pub-cache/hosted/pub.dev/cloud_firestore-5.4.4/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_auth","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_auth-5.3.1/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_core","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/","native_build":true,"dependencies":[]},{"name":"path_provider_foundation","path":"/Users/mika/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"shared_preferences_foundation","path":"/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"url_launcher_macos","path":"/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_macos-3.2.1/","native_build":true,"dependencies":[]}],"linux":[{"name":"path_provider_linux","path":"/Users/mika/.pub-cache/hosted/pub.dev/path_provider_linux-2.2.1/","native_build":false,"dependencies":[]},{"name":"shared_preferences_linux","path":"/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_linux-2.4.1/","native_build":false,"dependencies":["path_provider_linux"]},{"name":"url_launcher_linux","path":"/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_linux-3.2.0/","native_build":true,"dependencies":[]}],"windows":[{"name":"cloud_firestore","path":"/Users/mika/.pub-cache/hosted/pub.dev/cloud_firestore-5.4.4/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_auth","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_auth-5.3.1/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_core","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/","native_build":true,"dependencies":[]},{"name":"path_provider_windows","path":"/Users/mika/.pub-cache/hosted/pub.dev/path_provider_windows-2.3.0/","native_build":false,"dependencies":[]},{"name":"shared_preferences_windows","path":"/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_windows-2.4.1/","native_build":false,"dependencies":["path_provider_windows"]},{"name":"url_launcher_windows","path":"/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_windows-3.1.3/","native_build":true,"dependencies":[]}],"web":[{"name":"cloud_firestore_web","path":"/Users/mika/.pub-cache/hosted/pub.dev/cloud_firestore_web-4.3.2/","dependencies":["firebase_core_web"]},{"name":"firebase_auth_web","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_auth_web-5.13.2/","dependencies":["firebase_core_web"]},{"name":"firebase_core_web","path":"/Users/mika/.pub-cache/hosted/pub.dev/firebase_core_web-2.18.1/","dependencies":[]},{"name":"shared_preferences_web","path":"/Users/mika/.pub-cache/hosted/pub.dev/shared_preferences_web-2.4.2/","dependencies":[]},{"name":"url_launcher_web","path":"/Users/mika/.pub-cache/hosted/pub.dev/url_launcher_web-2.3.3/","dependencies":[]}]},"dependencyGraph":[{"name":"cloud_firestore","dependencies":["cloud_firestore_web","firebase_core"]},{"name":"cloud_firestore_web","dependencies":["firebase_core","firebase_core_web"]},{"name":"firebase_auth","dependencies":["firebase_auth_web","firebase_core"]},{"name":"firebase_auth_web","dependencies":["firebase_core","firebase_core_web"]},{"name":"firebase_core","dependencies":["firebase_core_web"]},{"name":"firebase_core_web","dependencies":[]},{"name":"path_provider","dependencies":["path_provider_android","path_provider_foundation","path_provider_linux","path_provider_windows"]},{"name":"path_provider_android","dependencies":[]},{"name":"path_provider_foundation","dependencies":[]},{"name":"path_provider_linux","dependencies":[]},{"name":"path_provider_windows","dependencies":[]},{"name":"shared_preferences","dependencies":["shared_preferences_android","shared_preferences_foundation","shared_preferences_linux","shared_preferences_web","shared_preferences_windows"]},{"name":"shared_preferences_android","dependencies":[]},{"name":"shared_preferences_foundation","dependencies":[]},{"name":"shared_preferences_linux","dependencies":["path_provider_linux"]},{"name":"shared_preferences_web","dependencies":[]},{"name":"shared_preferences_windows","dependencies":["path_provider_windows"]},{"name":"url_launcher","dependencies":["url_launcher_android","url_launcher_ios","url_launcher_linux","url_launcher_macos","url_launcher_web","url_launcher_windows"]},{"name":"url_launcher_android","dependencies":[]},{"name":"url_launcher_ios","dependencies":[]},{"name":"url_launcher_linux","dependencies":[]},{"name":"url_launcher_macos","dependencies":[]},{"name":"url_launcher_web","dependencies":[]},{"name":"url_launcher_windows","dependencies":[]}],"date_created":"2024-10-30 19:49:52.262075","version":"3.24.3","swift_package_manager_enabled":false}
```

# .gitignore

```
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

```

# .metadata

```
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "2663184aa79047d0a33a14a3b607954f8fdd8730"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
      base_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
    - platform: android
      create_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
      base_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
    - platform: ios
      create_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
      base_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
    - platform: linux
      create_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
      base_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
    - platform: macos
      create_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
      base_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
    - platform: web
      create_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
      base_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
    - platform: windows
      create_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730
      base_revision: 2663184aa79047d0a33a14a3b607954f8fdd8730

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'

```

# analysis_options.yaml

```yaml
include: package:flutter_lints/flutter.yaml

```

# firebase.json

```json
{
    "firestore": {
      "indexes": "firestore.indexes.json",
      "rules": "firestore.rules"
    }
  }

```

# firestore.indexes.json

```json
{
  "indexes": [
    {
      "collectionGroup": "userLists",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "sharedWith",
          "arrayConfig": "CONTAINS"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "sharedLists",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "ownerId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "sharedAt",
          "order": "DESCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": [
    {
      "collectionGroup": "publicProfile",
      "fieldPath": "email",
      "indexes": [
        {
          "order": "ASCENDING",
          "queryScope": "COLLECTION"
        }
      ]
    }
  ]
}
```

# firestore.rules

```rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isListMember(userId) {
      return request.auth.uid == userId || 
             (resource != null && 
              resource.data.sharedWith != null && 
              request.auth.uid in resource.data.sharedWith);
    }

    function isListOwner(userId) {
      return request.auth.uid == userId;
    }

    // User profile rules
    match /users/{userId} {
      allow read, write: if isAuthenticated();
    }

    // User settings rules
    match /userSettings/{userId} {
      allow read, write: if isAuthenticated();
    }

    // List rules - Erlaubt Zugriff auf den Listen-Root für beide Parteien
    match /lists/{userId} {
      allow read: if isAuthenticated();
      // Wichtig: Allow write auf dieser Ebene für beide Parteien
      allow write: if isAuthenticated();
      
      // Rules for user's own lists
      match /userLists/{listId} {
        allow read, create, update, delete: if isAuthenticated() &&
          (isListOwner(userId) || 
          (resource != null && resource.data.sharedWith != null && request.auth.uid in resource.data.sharedWith));
      }
      
      // Rules for shared lists
      match /sharedLists/{sharedListId} {
        // Erlaube das Erstellen, auch wenn der Benutzer noch nicht in sharedWith ist
        allow create: if isAuthenticated();  
        allow read, update, delete: if isAuthenticated() &&
          (isListOwner(userId) || 
          (resource != null && resource.data.sharedWith != null && request.auth.uid in resource.data.sharedWith));
      }
    }

    // Rate limiting rules
    match /rateLimit/{userId} {
      allow read, write: if isAuthenticated();
    }

    // List invite rules
    match /listInvites/{inviteId} {
      allow read, write: if isAuthenticated();
    }
  }
}
```

# lib/data/database.dart

```dart
import 'dart:async';
import 'package:Lists/data/firebase_service.dart';

class ShoppingDataBase {
  // Private instance of FirebaseService
  late FirebaseService _firebase;
  bool _isInitialized = false;

  // Local cache of current data
  List<Map<String, String>> currentShoppingList = [];
  String currentCurrency = '€';
  Map<String, String> _listNameCache = {};

  // Stream controllers for real-time updates
  final _listUpdateController =
      StreamController<List<Map<String, String>>>.broadcast();
  Stream<List<Map<String, String>>> get listUpdates =>
      _listUpdateController.stream;

  // Stream controller for currency updates
  final _currencyController = StreamController<String>.broadcast();
  Stream<String> get currencyUpdates => _currencyController.stream;

  // Categories (could be moved to Firestore later)
  List<String> categories = [
    'All',
    'Clothing',
    'Electronics',
    'Books',
    'Food',
    'Other'
  ];

  // Initialize stream subscription for real-time updates
  StreamSubscription? _listSubscription;

  // Initialize Firebase Service
  Future<void> initialize() async {
    if (!_isInitialized) {
      _firebase = await FirebaseService.create();
      _isInitialized = true;
    }
  }

  // Load currency preference from user settings
  Future<void> loadCurrency() async {
    await _ensureInitialized();
    try {
      final settings = await _firebase.loadUserSettings();
      currentCurrency = settings['currency'] ?? '€';
    } catch (e) {
      print('Error loading currency: $e');
      currentCurrency = '€'; // Fallback to default
    }
  }

  // Save currency preference to user settings
  Future<void> saveCurrency(String currency) async {
    await _ensureInitialized();
    try {
      await _firebase.saveUserSettings({'currency': currency});
      currentCurrency = currency;
      _currencyController.add(currency);

      if (!_listUpdateController.isClosed) {
        _listUpdateController.add(currentShoppingList);
      }
    } catch (e) {
      print('Error saving currency: $e');
      throw Exception('Failed to save currency preference');
    }
  }

  // Create a new shopping list
  Future<void> createNewList(String listName) async {
    await _ensureInitialized();
    try {
      await _firebase.createNewList(listName);
      currentShoppingList = [];
      _subscribeToListUpdates(listName);
    } catch (e) {
      print('Error creating new list: $e');
      rethrow;
    }
  }

  // Load list data and subscribe to updates
  Future<void> loadData(String listName) async {
    await _ensureInitialized();
    try {
      await loadCurrency();

      final items = await _firebase.loadListData(listName);
      currentShoppingList = _convertToStringMap(items);

      await _listSubscription?.cancel();
      _subscribeToListUpdates(listName);
    } catch (e) {
      print('Error loading data: $e');
      currentShoppingList = [];
      throw Exception('Failed to load list data');
    }
  }

  // Subscribe to real-time updates for current list
  void _subscribeToListUpdates(String listName) {
    _listSubscription?.cancel();

    try {
      _listSubscription = _firebase.getListStream(listName).listen((items) {
        if (!_listUpdateController.isClosed) {
          currentShoppingList = _convertToStringMap(items);
          _listUpdateController.add(currentShoppingList);
        }
      }, onError: (error) {
        print('Error in list subscription: $error');
      });
    } catch (e) {
      print('Error setting up subscription: $e');
    }
  }

  // Convert dynamic maps to string maps
  List<Map<String, String>> _convertToStringMap(List<dynamic> items) {
    return items.map((item) {
      if (item is Map) {
        return Map<String, String>.from(item
            .map((key, value) => MapEntry(key.toString(), value.toString())));
      }
      return <String, String>{};
    }).toList();
  }

  Future<void> updateDataBase(String listId) async {
    await _ensureInitialized();
    try {
      if (listId.contains('_')) {
        // Wenn es eine geteilte Liste ist
        final parts = listId.split('_');
        final originalOwnerId = parts[0];
        final originalListName = parts[1];

        await _firebase.updateSharedList(
            originalOwnerId, originalListName, currentShoppingList);
      } else {
        // Direkte Liste des Users
        await _firebase.updateList(listId, currentShoppingList);
      }
    } catch (e) {
      print('Error updating database: $e');
      throw Exception('Failed to update list');
    }
  }

  // Get display name for a list
  Future<String> getListDisplayName(String listId) async {
    await _ensureInitialized();
    if (_listNameCache.containsKey(listId)) {
      return _listNameCache[listId]!;
    }

    try {
      final names = await _firebase.batchLoadListNames([listId]);
      final displayName = names[listId] ?? listId;
      _listNameCache[listId] = displayName;
      return displayName;
    } catch (e) {
      print('Error getting list name: $e');
      return listId;
    }
  }

  // Delete a list
  Future<void> deleteList(String listName) async {
    await _ensureInitialized();
    try {
      await _firebase.deleteList(listName);
      _listNameCache.remove(listName);
    } catch (e) {
      print('Error deleting list: $e');
      throw Exception('Failed to delete list');
    }
  }

  // Get all lists for current user
  Future<List<String>> getAllListNames() async {
    await _ensureInitialized();
    try {
      final listIds = await _firebase.getAllListNames();

      // Clear and update cache
      _listNameCache.clear();
      final names = await _firebase.batchLoadListNames(listIds);
      _listNameCache.addAll(names);

      return listIds;
    } catch (e) {
      print('Error getting list names: $e');
      return [];
    }
  }

  // Share list with another user
  Future<void> shareList(String listName, String email) async {
    await _ensureInitialized();
    try {
      await _firebase.shareList(listName, email);
    } catch (e) {
      print('Error sharing list: $e');
      throw Exception('Failed to share list');
    }
  }

  Future<void> addItem(String listId, Map<String, String> item) async {
    await _ensureInitialized();
    try {
      if (!item['price']!.contains('€') && !item['price']!.contains('\$')) {
        item['price'] = '${item['price']}$currentCurrency';
      }

      currentShoppingList.add(item);
      await updateDataBase(listId);
    } catch (e) {
      print('Error adding item: $e');
      throw Exception('Failed to add item');
    }
  }

  // Update existing item
  Future<void> updateItem(
      String listName, int index, Map<String, String> newItem) async {
    await _ensureInitialized();
    try {
      if (index >= 0 && index < currentShoppingList.length) {
        currentShoppingList[index] = newItem;
        await updateDataBase(listName);
      }
    } catch (e) {
      print('Error updating item: $e');
      throw Exception('Failed to update item');
    }
  }

  // Delete item from list
  Future<void> deleteItem(String listName, int index) async {
    await _ensureInitialized();
    try {
      if (index >= 0 && index < currentShoppingList.length) {
        currentShoppingList.removeAt(index);
        await updateDataBase(listName);
      }
    } catch (e) {
      print('Error deleting item: $e');
      throw Exception('Failed to delete item');
    }
  }

  // Reorder items in list
  Future<void> reorderItems(String listName, int oldIndex, int newIndex) async {
    await _ensureInitialized();
    try {
      final item = currentShoppingList.removeAt(oldIndex);
      currentShoppingList.insert(newIndex, item);
      await updateDataBase(listName);
    } catch (e) {
      print('Error reordering items: $e');
      throw Exception('Failed to reorder items');
    }
  }

  // Ensure Firebase Service is initialized
  Future<void> _ensureInitialized() async {
    if (!_isInitialized) {
      await initialize();
    }
  }

  // Currency conversion helper
  double convertCurrency(String price, String fromCurrency, String toCurrency) {
    return _firebase.convertCurrency(price, fromCurrency, toCurrency);
  }

  // Cleanup resources
  void dispose() {
    _listSubscription?.cancel();
    _listUpdateController.close();
    _currencyController.close();
  }
}

```

# lib/data/firebase_service.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:shared_preferences/shared_preferences.dart';

class SharedListInfo {
  final String originalListId;
  final String ownerEmail;
  final String ownerId;
  final DateTime sharedAt;
  final List<String> sharedWithEmails;

  SharedListInfo({
    required this.originalListId,
    required this.ownerEmail,
    required this.ownerId,
    required this.sharedAt,
    required this.sharedWithEmails,
  });

  Map<String, dynamic> toMap() {
    return {
      'originalListId': originalListId,
      'ownerEmail': ownerEmail,
      'ownerId': ownerId,
      'sharedAt': sharedAt,
      'sharedWithEmails': sharedWithEmails,
    };
  }

  static SharedListInfo fromMap(Map<String, dynamic> map) {
    return SharedListInfo(
      originalListId: map['originalListId'] ?? '',
      ownerEmail: map['ownerEmail'] ?? '',
      ownerId: map['ownerId'] ?? '',
      sharedAt: (map['sharedAt'] as Timestamp).toDate(),
      sharedWithEmails: List<String>.from(map['sharedWithEmails'] ?? []),
    );
  }
}

class FirebaseService {
  // Core Firebase instances
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final SharedPreferences _prefs;

  bool _isInitialized = false;

  // Collection references
  late CollectionReference _listsCollection;
  late CollectionReference _userSettingsCollection;

  // Cache constants
  static const String _namesCachePrefix = 'list_name_';
  static const String _lastCacheUpdateKey = 'last_names_cache_update';
  static const int _cacheValidityDuration = 5 * 60 * 1000; // 5 minutes

  // Current user data
  String? get currentUserId => _auth.currentUser?.uid;

  // Private constructor for singleton pattern
  FirebaseService._create(this._prefs) {
    _listsCollection = _firestore.collection('lists');
    _userSettingsCollection = _firestore.collection('userSettings');
  }

  // Factory constructor
  static Future<FirebaseService> create() async {
    final prefs = await SharedPreferences.getInstance();
    return FirebaseService._create(prefs);
  }

  // Batch load list names with caching
  Future<Map<String, String>> batchLoadListNames(List<String> listIds) async {
    if (listIds.isEmpty) return {};

    final currentTime = DateTime.now().millisecondsSinceEpoch;
    final lastUpdate = _prefs.getInt(_lastCacheUpdateKey) ?? 0;
    final Map<String, String> results = {};
    final List<String> idsToFetch = [];

    // Check cache first
    for (String id in listIds) {
      final cachedName = _prefs.getString('$_namesCachePrefix$id');
      if (cachedName != null &&
          (currentTime - lastUpdate) < _cacheValidityDuration) {
        results[id] = cachedName;
      } else {
        idsToFetch.add(id);
      }
    }

    if (idsToFetch.isEmpty) return results;

    try {
      final Map<String, Future<DocumentSnapshot>> futures = {};

      for (String id in idsToFetch) {
        if (id.contains('_')) {
          futures[id] = _firestore
              .collection('lists')
              .doc(currentUserId)
              .collection('sharedLists')
              .doc(id)
              .get();
        } else {
          futures[id] = _firestore
              .collection('lists')
              .doc(currentUserId)
              .collection('userLists')
              .doc(id)
              .get();
        }
      }

      final responses = await Future.wait(futures.values);
      var index = 0;

      for (var id in futures.keys) {
        final doc = responses[index++];
        if (doc.exists) {
          final name = (doc.data() as Map<String, dynamic>)['name'] ?? id;
          results[id] = name;
          await _prefs.setString('$_namesCachePrefix$id', name);
        } else {
          results[id] = id;
        }
      }

      await _prefs.setInt(_lastCacheUpdateKey, currentTime);
      return results;
    } catch (e) {
      print('Error batch loading list names: $e');
      return results;
    }
  }

  // Cache management
  Future<void> clearNameCache() async {
    final keys = _prefs.getKeys();
    for (String key in keys) {
      if (key.startsWith(_namesCachePrefix)) {
        await _prefs.remove(key);
      }
    }
    await _prefs.remove(_lastCacheUpdateKey);
  }

  // List Operations
  Future<void> createNewList(String listName) async {
    if (currentUserId == null) return;

    await _listsCollection
        .doc(currentUserId)
        .collection('userLists')
        .doc(listName)
        .set({
      'name': listName,
      'createdAt': FieldValue.serverTimestamp(),
      'items': [],
      'sharedWith': [],
      'sharedWithEmails': [],
      'owner': currentUserId,
    });
  }

  Future<List<Map<String, dynamic>>> loadListData(String listName) async {
    if (currentUserId == null) return [];

    try {
      if (listName.contains('_')) {
        final sharedDoc = await _firestore
            .collection('lists')
            .doc(currentUserId)
            .collection('sharedLists')
            .doc(listName)
            .get();

        if (sharedDoc.exists) {
          return List<Map<String, dynamic>>.from(
              sharedDoc.data()?['items'] ?? []);
        }
      } else {
        final docSnapshot = await _firestore
            .collection('lists')
            .doc(currentUserId)
            .collection('userLists')
            .doc(listName)
            .get();

        if (docSnapshot.exists) {
          return List<Map<String, dynamic>>.from(
              docSnapshot.data()?['items'] ?? []);
        }
      }
      return [];
    } catch (e) {
      print('Error loading list data: $e');
      return [];
    }
  }

  Future<void> updateList(
      String listName, List<Map<String, dynamic>> items) async {
    if (currentUserId == null) return;

    try {
      // Update original list
      await _firestore
          .collection('lists')
          .doc(currentUserId)
          .collection('userLists')
          .doc(listName)
          .update({
        'items': items,
        'lastModified': FieldValue.serverTimestamp(),
      });

      // Get list info to find shared users
      final listDoc = await _firestore
          .collection('lists')
          .doc(currentUserId)
          .collection('userLists')
          .doc(listName)
          .get();

      // If list exists and has shared users, update their copies
      if (listDoc.exists) {
        final sharedWithUsers =
            List<String>.from(listDoc.data()?['sharedWith'] ?? []);

        // Update all shared copies
        for (final sharedUserId in sharedWithUsers) {
          await _firestore
              .collection('lists')
              .doc(sharedUserId)
              .collection('sharedLists')
              .doc('${currentUserId}_$listName')
              .update({
            'items': items,
            'lastModified': FieldValue.serverTimestamp(),
          });
        }
      }
    } catch (e) {
      print('Error updating list: $e');
      throw Exception('Failed to update list');
    }
  }

  Future<void> deleteList(String listName) async {
    if (currentUserId == null) return;

    final batch = _firestore.batch();

    try {
      if (listName.contains('_')) {
        final sharedListRef = _firestore
            .collection('lists')
            .doc(currentUserId)
            .collection('sharedLists')
            .doc(listName);

        batch.delete(sharedListRef);
      } else {
        final listRef = _firestore
            .collection('lists')
            .doc(currentUserId)
            .collection('userLists')
            .doc(listName);

        final doc = await listRef.get();

        if (doc.exists) {
          final sharedWithIds =
              List<String>.from(doc.data()?['sharedWith'] ?? []);

          for (final userId in sharedWithIds) {
            final sharedRef = _firestore
                .collection('lists')
                .doc(userId)
                .collection('sharedLists')
                .doc('${currentUserId}_$listName');

            batch.delete(sharedRef);
          }

          batch.delete(listRef);
        }
      }

      await batch.commit();
      // Clear cache for deleted list
      await _prefs.remove('$_namesCachePrefix$listName');
    } catch (e) {
      print('Error deleting list: $e');
      throw Exception('Failed to delete list: ${e.toString()}');
    }
  }

  // User Settings Operations
  Future<void> saveUserSettings(Map<String, dynamic> settings) async {
    if (currentUserId == null) return;

    await _userSettingsCollection
        .doc(currentUserId)
        .set(settings, SetOptions(merge: true));
  }

  Future<Map<String, dynamic>> loadUserSettings() async {
    if (!_isInitialized) return {};
    try {
      final docSnapshot =
          await _userSettingsCollection.doc(currentUserId).get();
      if (docSnapshot.exists) {
        return docSnapshot.data() as Map<String, dynamic>;
      }
      return {'currency': '€'};
    } catch (e) {
      print('Error loading user settings: $e');
      return {'currency': '€'};
    }
  }

  // Sharing Operations
  Future<void> shareList(String listName, String email) async {
    return shareListWithUser(listName, email);
  }

  Future<void> shareListWithUser(String listId, String targetEmail) async {
    if (currentUserId == null) throw Exception('Not authenticated');
    if (targetEmail == _auth.currentUser?.email) {
      throw Exception('Cannot share list with yourself');
    }

    try {
      if (!await checkShareRateLimit()) {
        throw Exception('Sharing rate limit exceeded. Please try again later.');
      }

      final userQuery = await _firestore
          .collection('users')
          .where('email', isEqualTo: targetEmail)
          .limit(1)
          .get();

      if (userQuery.docs.isEmpty) throw Exception('User not found');

      final targetUserId = userQuery.docs.first.id;
      final batch = _firestore.batch();

      final listDoc = await _firestore
          .collection('lists')
          .doc(currentUserId)
          .collection('userLists')
          .doc(listId)
          .get();

      if (!listDoc.exists) throw Exception('List does not exist');

      final listData = listDoc.data()!;
      final sharedListId = '${currentUserId}_$listId';

      // Update original list
      batch.update(
          _listsCollection
              .doc(currentUserId)
              .collection('userLists')
              .doc(listId),
          {
            'sharedWith': FieldValue.arrayUnion([targetUserId]),
            'sharedWithEmails': FieldValue.arrayUnion([targetEmail]),
            'lastModified': FieldValue.serverTimestamp(),
          });

      // Create shared list
      batch.set(
          _listsCollection
              .doc(targetUserId)
              .collection('sharedLists')
              .doc(sharedListId),
          {
            'originalListId': listId,
            'ownerId': currentUserId,
            'ownerEmail': _auth.currentUser?.email,
            'name': listData['name'] ?? listId,
            'items': listData['items'] ?? [],
            'sharedWith': [targetUserId],
            'sharedAt': FieldValue.serverTimestamp(),
            'lastModified': FieldValue.serverTimestamp(),
          });

      await batch.commit();
    } catch (e) {
      print('Error sharing list: $e');
      throw Exception('Failed to share list: ${e.toString()}');
    }
  }

  Future<bool> checkShareRateLimit() async {
    if (currentUserId == null) return false;

    try {
      final rateLimitDoc =
          await _firestore.collection('rateLimit').doc(currentUserId).get();

      if (!rateLimitDoc.exists) {
        await _firestore.collection('rateLimit').doc(currentUserId).set({
          'shareCount': 1,
          'timestamp': FieldValue.serverTimestamp(),
        });
        return true;
      }

      final data = rateLimitDoc.data() as Map<String, dynamic>;
      final timestamp = (data['timestamp'] as Timestamp).toDate();
      final count = data['shareCount'] as int;

      if (DateTime.now().difference(timestamp) > const Duration(hours: 24)) {
        await _firestore.collection('rateLimit').doc(currentUserId).set({
          'shareCount': 1,
          'timestamp': FieldValue.serverTimestamp(),
        });
        return true;
      }

      if (count >= 50) return false;

      await _firestore.collection('rateLimit').doc(currentUserId).update({
        'shareCount': FieldValue.increment(1),
      });

      return true;
    } catch (e) {
      print('Error checking rate limit: $e');
      return false;
    }
  }

  Stream<List<Map<String, dynamic>>> getListStream(String listName) {
    if (currentUserId == null) {
      return Stream.value([]);
    }

    try {
      if (listName.contains('_')) {
        return _firestore
            .collection('lists')
            .doc(currentUserId)
            .collection('sharedLists')
            .doc(listName)
            .snapshots()
            .handleError((error) {
          print('Error in shared list stream: $error');
          return [];
        }).map((snapshot) {
          if (!snapshot.exists) return [];
          return List<Map<String, dynamic>>.from(
              snapshot.data()?['items'] ?? []);
        });
      }

      return _firestore
          .collection('lists')
          .doc(currentUserId)
          .collection('userLists')
          .doc(listName)
          .snapshots()
          .handleError((error) {
        print('Error in list stream: $error');
        return [];
      }).map((snapshot) {
        if (!snapshot.exists) return [];
        return List<Map<String, dynamic>>.from(snapshot.data()?['items'] ?? []);
      });
    } catch (e) {
      print('Error setting up list stream: $e');
      return Stream.value([]);
    }
  }

  Future<List<String>> getAllListNames() async {
    if (currentUserId == null) return [];

    try {
      final lists = <String>[];

      final ownedLists = await _firestore
          .collection('lists')
          .doc(currentUserId)
          .collection('userLists')
          .get();

      lists.addAll(ownedLists.docs.map((doc) => doc.id));

      final sharedLists = await _firestore
          .collection('lists')
          .doc(currentUserId)
          .collection('sharedLists')
          .get();

      lists.addAll(sharedLists.docs.map((doc) => doc.id));

      return lists;
    } catch (e) {
      print('Error getting list names: $e');
      return [];
    }
  }

  // Currency conversion helper
  double convertCurrency(String price, String fromCurrency, String toCurrency) {
    final numericPrice = double.parse(price.replaceAll(RegExp(r'[€$]'), ''));

    if (fromCurrency == toCurrency) return numericPrice;

    const eurToUsdRate = 1.18;

    if (fromCurrency == '\$' && toCurrency == '€') {
      return numericPrice / eurToUsdRate;
    } else if (fromCurrency == '€' && toCurrency == '\$') {
      return numericPrice * eurToUsdRate;
    }

    return numericPrice;
  }

  Future<void> updateSharedList(
    String ownerId, String listName, List<Map<String, dynamic>> items) async {
  try {
    // Bestimme, ob der aktuelle User der Owner ist
    bool isOwner = currentUserId == ownerId;

    if (isOwner) {
      // Wenn Owner, nutze updateList Methode
      await updateList(listName, items);
    } else {
      // Wenn shared User, update original und shared copies
      // Update original list
      await _firestore
          .collection('lists')
          .doc(ownerId)
          .collection('userLists')
          .doc(listName)
          .update({
        'items': items,
        'lastModified': FieldValue.serverTimestamp(),
      });

      // Get all shared users
      final originalListDoc = await _firestore
          .collection('lists')
          .doc(ownerId)
          .collection('userLists')
          .doc(listName)
          .get();

      if (originalListDoc.exists) {
        final sharedWithUsers =
            List<String>.from(originalListDoc.data()?['sharedWith'] ?? []);

        // Update all shared copies
        for (final sharedUserId in sharedWithUsers) {
          await _firestore
              .collection('lists')
              .doc(sharedUserId)
              .collection('sharedLists')
              .doc('${ownerId}_$listName')
              .update({
            'items': items,
            'lastModified': FieldValue.serverTimestamp(),
          });
        }
      }

      // Update owner's shared copy
      await _firestore
          .collection('lists')
          .doc(currentUserId)
          .collection('sharedLists')
          .doc('${ownerId}_$listName')
          .update({
        'items': items,
        'lastModified': FieldValue.serverTimestamp(),
      });
    }
  } catch (e) {
    print('Error updating shared list: $e');
    throw Exception('Failed to update shared list');
  }
}

  Future<Map<String, String>?> getOriginalListInfo(String sharedListId) async {
    try {
      final sharedDoc = await _firestore
          .collection('lists')
          .doc(currentUserId)
          .collection('sharedLists')
          .doc(sharedListId)
          .get();

      if (sharedDoc.exists) {
        return {
          'ownerId': sharedDoc.data()?['ownerId'] ?? '',
          'originalListName': sharedDoc.data()?['originalListId'] ?? '',
        };
      }
      return null;
    } catch (e) {
      print('Error getting original list info: $e');
      return null;
    }
  }

  Stream<List<Map<String, dynamic>>> getSharedListsStream() {
    if (currentUserId == null) return Stream.value([]);

    return _listsCollection
        .doc(currentUserId)
        .collection('sharedLists')
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data();
        return {
          'name': doc.id,
          'ownerEmail': data['ownerEmail'],
          'sharedAt': data['sharedAt'],
          'items': data['items'] ?? [],
        };
      }).toList();
    });
  }

  // Cleanup method for testing or user logout
  Future<void> cleanup() async {
    await clearNameCache();
  }
}

```

# lib/firebase_options.dart

```dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// \`\`\`dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// \`\`\`
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAkNpM9zjRdo08l7lr1epMDcUXh6F2OWgY',
    appId: '1:352172024344:android:5fb6d109b74a3d3064196d',
    messagingSenderId: '352172024344',
    projectId: 'listsapplication',
    storageBucket: 'listsapplication.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyB-agBAtRH-5JNXddpriqib5etJ5b8LS1k',
    appId: '1:352172024344:ios:f1bce6d4ac572e3664196d',
    messagingSenderId: '352172024344',
    projectId: 'listsapplication',
    storageBucket: 'listsapplication.appspot.com',
    iosBundleId: 'com.NoBuildStudios.listsApplication',
  );
}

```

# lib/main.dart

```dart
import 'dart:io';
import 'package:Lists/firebase_options.dart';
import 'package:Lists/pages/auth_page.dart';
import 'package:Lists/theme/theme.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:Lists/pages/home_page.dart';

void main() async {
  // Initialize Flutter bindings
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // Configure platform-specific UI settings
  if (Platform.isAndroid) {
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        systemNavigationBarColor: Colors.black,
        systemNavigationBarDividerColor: Colors.transparent,
      ),
    );
  }

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: "Lists",
      theme: lightMode,
      darkTheme: darkMode,
      themeAnimationDuration: const Duration(milliseconds: 300),
      themeAnimationCurve: Curves.easeInOut,
      home: StreamBuilder<User?>(
        stream: FirebaseAuth.instance.authStateChanges(),
        builder: (context, snapshot) {
          // Show loading indicator while checking auth state
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const LoadingScreen();
          }
          
          // Show auth screen if not logged in, home page if logged in
          return snapshot.hasData ? const HomePage() : const AuthScreen();
        },
      ),
    );
  }
}

class LoadingScreen extends StatelessWidget {
  const LoadingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.surface,
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(
              color: Theme.of(context).colorScheme.secondary,
            ),
            const SizedBox(height: 16),
            Text(
              'Loading...',
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSurface,
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

# lib/pages/auth_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:Lists/pages/home_page.dart';
import 'package:Lists/util/my_button.dart';

class AuthScreen extends StatefulWidget {
  const AuthScreen({super.key});

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> {
  final _auth = FirebaseAuth.instance;
  final _firestore = FirebaseFirestore.instance;
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  final _emailFocus = FocusNode();
  final _passwordFocus = FocusNode();
  
  bool _isLogin = true;
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _emailFocus.dispose();
    _passwordFocus.dispose();
    super.dispose();
  }

  void _fieldFocusChange(
    BuildContext context, 
    FocusNode currentFocus, 
    FocusNode nextFocus
  ) {
    currentFocus.unfocus();
    FocusScope.of(context).requestFocus(nextFocus);
  }

  Future<void> _submitForm() async {
    // Unfocus keyboard
    _emailFocus.unfocus();
    _passwordFocus.unfocus();

    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      UserCredential userCredential;
      
      if (_isLogin) {
        // Login
        userCredential = await _auth.signInWithEmailAndPassword(
          email: _emailController.text.trim(),
          password: _passwordController.text.trim(),
        );
      } else {
        // Registrierung
        userCredential = await _auth.createUserWithEmailAndPassword(
          email: _emailController.text.trim(),
          password: _passwordController.text.trim(),
        );

        // Create user document in Firestore
        await _firestore.collection('users').doc(userCredential.user!.uid).set({
          'email': _emailController.text.trim(),
          'createdAt': FieldValue.serverTimestamp(),
        });
      }

      if (mounted) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (context) => const HomePage()),
        );
      }
    } on FirebaseAuthException catch (e) {
      setState(() {
        switch (e.code) {
          case 'user-not-found':
            _errorMessage = 'No user found with this email.';
            break;
          case 'wrong-password':
            _errorMessage = 'Wrong password provided.';
            break;
          case 'email-already-in-use':
            _errorMessage = 'An account already exists with this email.';
            break;
          case 'invalid-email':
            _errorMessage = 'The email address is invalid.';
            break;
          case 'weak-password':
            _errorMessage = 'The password must be at least 6 characters.';
            break;
          default:
            _errorMessage = e.message ?? 'An error occurred.';
        }
      });
    } catch (e) {
      setState(() {
        _errorMessage = 'An unexpected error occurred.';
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        // Unfocus when tapping outside
        FocusScope.of(context).unfocus();
      },
      child: Scaffold(
        backgroundColor: Theme.of(context).colorScheme.surface,
        body: SafeArea(
          child: Center(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(24),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // Logo
                    Icon(
                      Icons.shopping_cart,
                      size: 64,
                      color: Theme.of(context).colorScheme.secondary,
                    ),
                    const SizedBox(height: 32),
                    
                    // Title
                    Text(
                      'Shopping Lists',
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: Theme.of(context).colorScheme.onSurface,
                      ),
                    ),
                    const SizedBox(height: 48),

                    // Email Field
                    TextFormField(
                      controller: _emailController,
                      focusNode: _emailFocus,
                      keyboardType: TextInputType.emailAddress,
                      textInputAction: TextInputAction.next,
                      autocorrect: false,
                      enableSuggestions: false,
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.onSurface,
                      ),
                      decoration: InputDecoration(
                        labelText: 'Email',
                        prefixIcon: Icon(
                          Icons.email,
                          color: Theme.of(context).colorScheme.onSurface,
                        ),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      onFieldSubmitted: (_) {
                        _fieldFocusChange(context, _emailFocus, _passwordFocus);
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter your email';
                        }
                        if (!value.contains('@')) {
                          return 'Please enter a valid email';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Password Field
                    TextFormField(
                      controller: _passwordController,
                      focusNode: _passwordFocus,
                      obscureText: true,
                      textInputAction: TextInputAction.done,
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.onSurface,
                      ),
                      decoration: InputDecoration(
                        labelText: 'Password',
                        prefixIcon: Icon(
                          Icons.lock,
                          color: Theme.of(context).colorScheme.onSurface,
                        ),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      onFieldSubmitted: (_) => _submitForm(),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter your password';
                        }
                        if (!_isLogin && value.length < 6) {
                          return 'Password must be at least 6 characters';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 24),

                    // Error Message
                    if (_errorMessage != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 16),
                        child: Text(
                          _errorMessage!,
                          style: TextStyle(
                            color: Theme.of(context).colorScheme.error,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ),

                    // Submit Button
                    MyButton(
                      text: _isLogin ? 'Login' : 'Sign Up',
                      onPressed: _submitForm,
                      isLoading: _isLoading,
                      width: double.infinity,
                    ),
                    const SizedBox(height: 16),

                    // Toggle Login/Signup
                    TextButton(
                      onPressed: () {
                        setState(() {
                          _isLogin = !_isLogin;
                          _errorMessage = null;
                        });
                      },
                      child: Text(
                        _isLogin
                            ? 'Don\'t have an account? Sign Up'
                            : 'Already have an account? Login',
                        style: TextStyle(
                          color: Theme.of(context).colorScheme.onSurface,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

# lib/pages/home_page.dart

```dart
import 'package:Lists/pages/auth_page.dart';
import 'package:Lists/util/categorie_filter.dart';
import 'package:Lists/util/my_button.dart';
import 'package:Lists/util/my_drawer.dart';
import 'package:Lists/util/my_reorderable_list_view.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:Lists/data/database.dart';
import 'package:Lists/util/data_tile.dart';
import 'package:Lists/util/shopping_tile.dart';
import 'package:Lists/util/dialog_box.dart';

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> with TickerProviderStateMixin {
  // Database instance
  final ShoppingDataBase db = ShoppingDataBase();
  
  // Current state
  String currentListName = 'Default List';
  List<String> listNames = [];
  bool _isLoading = true;
  bool _mounted = true;
  
  // Controllers
  final _nameController = TextEditingController();
  final _priceController = TextEditingController();
  final _linkController = TextEditingController();
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();
  late ScrollController _scrollController;
  
  // Animation controllers
  late AnimationController _fadeController;
  late AnimationController _slideController;
  late AnimationController _scaleController;
  late AnimationController _rotationController;
  
  // Animations
  late Animation<Offset> _slideAnimation;
  late Animation<double> _scaleAnimation;
  
  String _selectedCategory = 'All';
  
  @override
  void initState() {
    super.initState();
    _initializeControllers();
    _setupAnimations();
    _loadInitialData();
  }

  Future<void> _loadInitialData() async {
    if (!mounted) return;
    try {
      setState(() => _isLoading = true);
      
      await db.initialize();
      
      // Listen auf Auth-Änderungen
      FirebaseAuth.instance.authStateChanges().listen((User? user) {
        if (!_mounted) return;  // Early return wenn nicht mehr mounted
        if (user == null && mounted) {
          Navigator.of(context).pushReplacement(
            MaterialPageRoute(builder: (context) => const AuthScreen()),
          );
        }
      });

      // Lade initiale Daten
      if (_mounted) {  // Prüfe mounted status
        await initializeData();
      }
      
      // Setup real-time updates
      if (_mounted) {  // Prüfe mounted status
        db.listUpdates.listen(
          (updatedList) {
            if (_mounted && mounted) {  // Doppelte Prüfung
              setState(() {
                db.currentShoppingList = updatedList;
              });
            }
          },
          onError: (error) {
            print('Error in list updates: $error');
          },
        );
      }

    } catch (e) {
      print('Error in initialization: $e');
      if (_mounted && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading data: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (_mounted && mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  void dispose() {
    _mounted = false;
    db.dispose();
    _fadeController.dispose();
    _slideController.dispose();
    _scaleController.dispose();
    _rotationController.dispose();
    _scrollController.dispose();
    _nameController.dispose();
    _priceController.dispose();
    _linkController.dispose();
    super.dispose();
  }

  Future<void> _initializeData() async {
    try {
      await initializeData();
      
      // Subscribe to real-time updates
      db.listUpdates.listen((updatedList) {
        if (mounted) {
          setState(() {
            db.currentShoppingList = updatedList;
          });
        }
      });
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading data: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  void _handleCurrencyChange(String newCurrency) async {
  try {
    await db.saveCurrency(newCurrency);
    setState(() {}); // Trigger rebuild to update the UI
  } catch (e) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to change currency: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }
}

  // Handle list sharing
  Future<void> _handleShareList(String email) async {
    try {
      await db.shareList(currentListName, email);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('List shared with $email', style: TextStyle(color: Theme.of(context).colorScheme.onSecondary),),
            backgroundColor: Theme.of(context).colorScheme.secondary,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to share list: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
      rethrow;
    }
  }

  void _initializeControllers() {
    _scrollController = ScrollController();
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _slideController = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );
    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );
    _rotationController = AnimationController(
      duration: const Duration(seconds: 1),
      vsync: this,
    );
  }

  void _setupAnimations() {
    _slideAnimation = Tween<Offset>(
      begin: const Offset(-1.0, 0.0),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _slideController,
      curve: Curves.easeOutCubic,
    ));

    _scaleAnimation = CurvedAnimation(
      parent: _scaleController,
      curve: Curves.easeOutBack,
    );

    _fadeController.forward();
    _slideController.forward();
    _scaleController.forward();
  }

  Future<void> initializeData() async {
    setState(() => _isLoading = true);

    try {
      final names = await db.getAllListNames();
      setState(() {
        listNames = names;
      });

      if (listNames.isEmpty) {
        await db.createNewList(currentListName);
        setState(() {
          listNames = [currentListName];
        });
      } else {
        setState(() {
          currentListName = listNames.first;
        });
      }

      await db.loadData(currentListName);

      _fadeController.forward();
      _slideController.forward();
      _scaleController.forward();
    } catch (e) {
      _showError('Error initializing data: $e');
    } finally {
      setState(() => _isLoading = false);
    }
  }

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        behavior: SnackBarBehavior.floating,
        backgroundColor: Colors.red,
        action: SnackBarAction(
          label: 'Retry',
          onPressed: initializeData,
          textColor: Colors.white,
        ),
      ),
    );
  }

  void onChangedCategory(String? newValue) {
    setState(() {
      _selectedCategory = newValue!;
      _fadeController.forward(from: 0.0);
    });
  }

  Future<void> createNewList() async {
    final TextEditingController listNameController = TextEditingController();

    final bool? shouldCreate = await showDialog<bool>(
      context: context,
      builder: (context) => _buildCreateListDialog(listNameController),
    );

    if (shouldCreate == true && listNameController.text.isNotEmpty) {
      setState(() {
        currentListName = listNameController.text;
      });
      await db.createNewList(currentListName);
      final names = await db.getAllListNames();
      setState(() {
        listNames = names;
      });

      _fadeController.forward(from: 0.0);
      _slideController.forward(from: 0.0);
      _scaleController.forward(from: 0.0);
    }
  }

  Future<void> createNewProduct() async {
    _nameController.clear();
    _priceController.clear();
    _linkController.clear();

    final bool? shouldCreate = await showDialog<bool>(
      context: context,
      builder: (context) => DialogBox(
        nameController: _nameController,
        priceController: _priceController,
        linkController: _linkController,
        onChangedCategory: onChangedCategory,
        onSave: () => Navigator.of(context).pop(true),
        categories: db.categories,
        selectedCategory: _selectedCategory,
        onCancel: () => Navigator.of(context).pop(false),
      ),
    );

    if (shouldCreate == true) {
      if (_nameController.text.isEmpty || _priceController.text.isEmpty) return;

      await db.addItem(currentListName, {
        'name': _nameController.text,
        'price': _priceController.text,
        'link': _linkController.text,
        'category': _selectedCategory
      });

      if (_scrollController.hasClients) {
        await _scrollController.animateTo(
          _scrollController.position.maxScrollExtent + 100,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    }
  }

  Future<void> updateProduct(int index) async {
    Map<String, String> updatedItem = {};

    updatedItem['name'] = _nameController.text.isNotEmpty
        ? _nameController.text
        : db.currentShoppingList[index]['name'] ?? '';

    updatedItem['price'] = _priceController.text.isNotEmpty
        ? _priceController.text
        : db.currentShoppingList[index]['price'] ?? '';

    updatedItem['link'] = _linkController.text.isNotEmpty
        ? _linkController.text
        : db.currentShoppingList[index]['link'] ?? '';

    updatedItem['category'] = _selectedCategory;

    await db.updateItem(currentListName, index, updatedItem);
  }

  Future<void> deleteProduct(int index) async {
    final deletedItem = Map<String, String>.from(db.currentShoppingList[index]);
    
    await db.deleteItem(currentListName, index);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        backgroundColor: Theme.of(context).colorScheme.secondary,
        content: Text(
          'Item deleted',
          style: TextStyle(color: Theme.of(context).colorScheme.onSecondary),
        ),
        action: SnackBarAction(
          label: 'Undo',
          onPressed: () async {
            db.currentShoppingList.insert(index, deletedItem);
            await db.updateDataBase(currentListName);
          },
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: _scaffoldKey,
      backgroundColor: Theme.of(context).colorScheme.surface,
      floatingActionButton: ScaleTransition(
        scale: _scaleAnimation,
        child: FloatingActionButton(
          backgroundColor: Theme.of(context).colorScheme.secondary,
          onPressed: createNewProduct,
          child: Icon(
            Icons.add,
            color: Theme.of(context).colorScheme.onSecondary,
          ),
        ),
      ),
      drawer: MyDrawer(
        listNames: listNames,
        currentListName: currentListName,
        onCreateNewList: createNewList,
        onListChange: (String selectedList) async {
          setState(() {
            currentListName = selectedList;
          });
          await db.loadData(currentListName);
        },
        onDeleteList: (String listName) async {
          await db.deleteList(listName);
          final names = await db.getAllListNames();
          setState(() {
            listNames = names;
            if (currentListName == listName) {
              if (listNames.isNotEmpty) {
                currentListName = listNames.first;
                db.loadData(currentListName);
              } else {
                currentListName = 'Default List';
                db.createNewList(currentListName);
                listNames = [currentListName];
              }
            }
          });
        },
        onCurrencyChange: _handleCurrencyChange,
        onShareList: _handleShareList,
        currentCurrency: db.currentCurrency,
      ),
      body: SafeArea(
        child: _isLoading
            ? _buildLoadingState()
            : Column(
                children: [
                  _buildHeader(),
                  const SizedBox(height: 20),
                  _buildCategoryFilter(),
                  const SizedBox(height: 10),
                  _buildShoppingList(),
                ],
              ),
      ),
    );
  }

  Widget _buildHeader() {
    return Padding(
      padding: const EdgeInsets.only(top: 20, left: 25, right: 25),
      child: Row(
        children: [
          SizedBox(
            width: 48,
            child: IconButton(
              icon: AnimatedBuilder(
                animation: _slideController,
                builder: (context, child) {
                  return Transform.rotate(
                    angle: _slideController.value * 0.5,
                    child: Icon(
                      Icons.menu,
                      color: Theme.of(context).colorScheme.onPrimary,
                      size: 28,
                    ),
                  );
                },
              ),
              onPressed: () => _scaffoldKey.currentState?.openDrawer(),
              splashRadius: 24,
              tooltip: 'Open menu',
            ),
          ),
          Expanded(
            child: ScaleTransition(
              scale: _scaleAnimation,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Flexible(
                    child: ConstrainedBox(
                      constraints: const BoxConstraints(maxWidth: 140),
                      child: DataTile(
                        data: db.currentShoppingList.length.toString(),
                      ),
                    ),
                  ),
                  const SizedBox(width: 20),
                  Flexible(
                    child: ConstrainedBox(
                      constraints: const BoxConstraints(maxWidth: 140),
                      child: DataTile(
                        data:
                            '${totalPrice.toStringAsFixed(2)}${db.currentCurrency}',
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(width: 48),
        ],
      ),
    );
  }

  Widget _buildCategoryFilter() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 25.0),
      child: SlideTransition(
        position: _slideAnimation,
        child: CategoryFilter(
          selectedCategory: _selectedCategory,
          onCategoryChanged: onChangedCategory,
          categories: [...db.categories],
        ),
      ),
    );
  }

  Widget _buildShoppingList() {
    return Expanded(
      child: filteredList.isEmpty
          ? _buildEmptyState()
          : Theme(
              data: Theme.of(context).copyWith(
                canvasColor: Colors.transparent,
                pageTransitionsTheme: const PageTransitionsTheme(
                  builders: {
                    TargetPlatform.android: FadeUpwardsPageTransitionsBuilder(),
                    TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
                  },
                ),
              ),
              child: CustomReorderableListView(
                itemCount: filteredList.length,
                onReorder: (oldIndex, newIndex) async {
                  final item = filteredList[oldIndex];

                  final originalIndex = db.currentShoppingList.indexWhere(
                      (element) =>
                          element['name'] == item['name'] &&
                          element['price'] == item['price'] &&
                          element['link'] == item['link']);

                  if (newIndex > oldIndex) {
                    newIndex = newIndex - 1;
                  }
                  List<int> mainListIndices = [];
                  for (var filteredItem in filteredList) {
                    int index = db.currentShoppingList.indexWhere((element) =>
                        element['name'] == filteredItem['name'] &&
                        element['price'] == filteredItem['price'] &&
                        element['link'] == filteredItem['link']);
                    if (index != -1) {
                      mainListIndices.add(index);
                    }
                  }

                  int targetMainIndex;
                  if (newIndex >= mainListIndices.length) {
                    targetMainIndex = mainListIndices.last;
                  } else {
                    targetMainIndex = mainListIndices[newIndex];
                  }

                  if (originalIndex != -1) {
                    setState(() {
                      filteredList.removeAt(oldIndex);
                      filteredList.insert(newIndex, item);
                    });
                    await db.reorderItems(
                        currentListName, originalIndex, targetMainIndex);
                  }
                },
                itemBuilder: (context, index) {
                  final item = filteredList[index];
                  return ShoppingTile(
                    key: ValueKey('${item['name']}_${item['price']}_$index'),
                    productName: item['name'] ?? '',
                    productPrice: item['price'] ?? '',
                    productLink: item['link'] ?? '',
                    currency: db.currentCurrency,
                    nameController: _nameController,
                    priceController: _priceController,
                    linkController: _linkController,
                    categories: db.categories,
                    selectedCategory: _selectedCategory,
                    onChangedCategory: onChangedCategory,
                    deleteFunction: (context) {
                      final originalIndex = db.currentShoppingList.indexWhere(
                          (element) =>
                              element['name'] == item['name'] &&
                              element['price'] == item['price'] &&
                              element['link'] == item['link']);
                      if (originalIndex != -1) {
                        deleteProduct(originalIndex);
                      }
                    },
                    editFunction: (context) {
                      final originalIndex = db.currentShoppingList.indexWhere(
                          (element) =>
                              element['name'] == item['name'] &&
                              element['price'] == item['price'] &&
                              element['link'] == item['link']);
                      if (originalIndex != -1) {
                        updateProduct(originalIndex);
                      }
                    },
                    index: index,
                  );
                },
              ),
            ),
    );
  }

  Widget _buildLoadingState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(
            color: Theme.of(context).colorScheme.secondary,
          ),
          const SizedBox(height: 16),
          Text(
            'Loading your lists...',
            style: TextStyle(
              color: Theme.of(context).colorScheme.onPrimary,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.shopping_cart_outlined,
            size: 48,
            color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.5),
          ),
          const SizedBox(height: 16),
          Text(
            "No Items Yet",
            style: TextStyle(
              color: Theme.of(context).colorScheme.onPrimary,
              fontWeight: FontWeight.bold,
              fontSize: 20,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            "Tap the + button to add items",
            style: TextStyle(
              color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.7),
              fontSize: 16,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCreateListDialog(TextEditingController controller) {
    return TweenAnimationBuilder<double>(
      duration: const Duration(milliseconds: 300),
      tween: Tween(begin: 0.0, end: 1.0),
      builder: (context, value, child) {
        return Transform.scale(
          scale: value,
          child: AlertDialog(
            backgroundColor: Theme.of(context).colorScheme.surface,
            title: Text(
              'Create New List',
              style: TextStyle(
                color: Theme.of(context).colorScheme.onPrimary,
              ),
            ),
            content: TextField(
              controller: controller,
              autofocus: true,
              style: TextStyle(
                color: Theme.of(context).colorScheme.onPrimary,
              ),
              decoration: InputDecoration(
                hintText: 'Enter list name',
                hintStyle: TextStyle(
                  color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.5),
                ),
                enabledBorder: UnderlineInputBorder(
                  borderSide: BorderSide(
                    color: Theme.of(context).colorScheme.onPrimary,
                  ),
                ),
                focusedBorder: UnderlineInputBorder(
                  borderSide: BorderSide(
                    color: Theme.of(context).colorScheme.secondary,
                    width: 2,
                  ),
                ),
              ),
            ),
            actions: [
              MyButton(
                text: "Cancel",
                onPressed: () => Navigator.pop(context, false),
              ),
              MyButton(
                text: "Create",
                onPressed: () => Navigator.pop(context, true),
              ),
            ],
          ),
        );
      },
    );
  }

  double get totalPrice {
    double sum = 0;
    for (var item in db.currentShoppingList) {
      String price = item['price'] ?? '0';
      String originalCurrency = price.contains('€') ? '€' : '\$';
      price = price.replaceAll(RegExp(r'[€$]'), '');

      double convertedPrice = db.convertCurrency(
        price,
        originalCurrency,
        db.currentCurrency,
      );

      sum += convertedPrice;
    }
    return sum;
  }

  List<Map<String, String>> get filteredList {
    if (_selectedCategory == 'All') {
      return List<Map<String, String>>.from(db.currentShoppingList);
    }
    return List<Map<String, String>>.from(db.currentShoppingList
        .where((item) => item['category'] == _selectedCategory));
  }
}
```

# lib/theme/theme.dart

```dart
import 'package:flutter/material.dart';

// Light theme configuration
ThemeData lightMode = ThemeData(
  // Enable Material 3 design system
  useMaterial3: true,

  // Set light mode brightness
  brightness: Brightness.light,

  // Define color scheme for light mode
  colorScheme: const ColorScheme.light(
    surface: Color.fromARGB(255, 245, 243, 236),     // Background surface color
    onPrimary: Color.fromARGB(255, 0, 0, 0),         // Text color on primary background
    primary: Color.fromARGB(175, 207, 202, 199),     // Primary color for main elements
    secondary: Color.fromARGB(166, 178, 212, 178),   // Accent color for interactive elements
    onSecondary: Color.fromARGB(255, 0, 0, 0),       // Text color on secondary background
    tertiary: Color.fromARGB(255, 156, 175, 136),    // Additional accent color
    onTertiary: Color.fromARGB(255, 255, 255, 255),  // Text color on tertiary background
  ),

  // Configure platform-specific page transitions
  pageTransitionsTheme: const PageTransitionsTheme(
    builders: {
      TargetPlatform.android: ZoomPageTransitionsBuilder(),      // Android zoom transition
      TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),     // iOS slide transition
      TargetPlatform.windows: OpenUpwardsPageTransitionsBuilder(), // Windows upward transition
      TargetPlatform.macOS: CupertinoPageTransitionsBuilder(),    // macOS slide transition
      TargetPlatform.linux: OpenUpwardsPageTransitionsBuilder(),  // Linux upward transition
    },
  ),

  // Configure card appearance
  cardTheme: CardTheme(
    elevation: 4,                                      // Card shadow depth
    shadowColor: Colors.black.withOpacity(0.2),       // Subtle shadow color
    shape: RoundedRectangleBorder(                    // Rounded corners for cards
      borderRadius: BorderRadius.circular(12),
    ),
  ),

  // Configure input field appearance
  inputDecorationTheme: InputDecorationTheme(
    filled: true,                                     // Enable background fill
    fillColor: const Color.fromARGB(255, 245, 243, 236).withOpacity(0.5),  // Light background
    border: OutlineInputBorder(                       // Default border style
      borderRadius: BorderRadius.circular(12),
      borderSide: const BorderSide(color: Color.fromARGB(175, 207, 202, 199)),
    ),
    enabledBorder: OutlineInputBorder(                // Border when field is enabled
      borderRadius: BorderRadius.circular(12),
      borderSide: const BorderSide(color: Color.fromARGB(175, 207, 202, 199)),
    ),
    focusedBorder: OutlineInputBorder(                // Border when field is focused
      borderRadius: BorderRadius.circular(12),
      borderSide: const BorderSide(color: Color.fromARGB(166, 178, 212, 178), width: 2),
    ),
  ),

  // Configure elevated button appearance
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ButtonStyle(
      animationDuration: const Duration(milliseconds: 200),  // Button press animation duration
      padding: WidgetStateProperty.all(                      // Consistent button padding
        const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
      shape: WidgetStateProperty.all(                        // Rounded button corners
        RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
    ),
  ),
);

// Dark theme configuration
ThemeData darkMode = ThemeData(
  // Enable Material 3 design system
  useMaterial3: true,

  // Set dark mode brightness
  brightness: Brightness.dark,

  // Define color scheme for dark mode
  colorScheme: const ColorScheme.dark(
    surface: Color.fromARGB(255, 50, 50, 50),        // Dark background surface color
    onPrimary: Color.fromARGB(255, 255, 255, 255),   // Text color on primary background
    primary: Color.fromARGB(255, 76, 76, 76),        // Primary color for main elements
    secondary: Color.fromRGBO(125, 26, 255, 1),    // Accent color for interactive elements
    onSecondary: Color.fromARGB(255, 255, 255, 255), // Text color on secondary background
    tertiary: Color.fromARGB(255, 90, 24, 154),      // Additional accent color
    onTertiary: Color.fromARGB(255, 255, 255, 255),  // Text color on tertiary background
  ),

  // Configure platform-specific page transitions
  pageTransitionsTheme: const PageTransitionsTheme(
    builders: {
      TargetPlatform.android: ZoomPageTransitionsBuilder(),      // Android zoom transition
      TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),     // iOS slide transition
      TargetPlatform.windows: OpenUpwardsPageTransitionsBuilder(), // Windows upward transition
      TargetPlatform.macOS: CupertinoPageTransitionsBuilder(),    // macOS slide transition
      TargetPlatform.linux: OpenUpwardsPageTransitionsBuilder(),  // Linux upward transition
    },
  ),

  // Configure card appearance for dark mode
  cardTheme: CardTheme(
    elevation: 4,                                      // Card shadow depth
    shadowColor: Colors.black.withOpacity(0.4),       // Stronger shadow for dark mode
    shape: RoundedRectangleBorder(                    // Rounded corners for cards
      borderRadius: BorderRadius.circular(12),
    ),
  ),

  // Configure input field appearance for dark mode
  inputDecorationTheme: InputDecorationTheme(
    filled: true,                                     // Enable background fill
    fillColor: const Color.fromARGB(255, 76, 76, 76).withOpacity(0.5),  // Dark background
    border: OutlineInputBorder(                       // Default border style
      borderRadius: BorderRadius.circular(12),
      borderSide: const BorderSide(color: Color.fromARGB(255, 90, 90, 90)),
    ),
    enabledBorder: OutlineInputBorder(                // Border when field is enabled
      borderRadius: BorderRadius.circular(12),
      borderSide: const BorderSide(color: Color.fromARGB(255, 90, 90, 90)),
    ),
    focusedBorder: OutlineInputBorder(                // Border when field is focused
      borderRadius: BorderRadius.circular(12),
      borderSide: const BorderSide(color: Color.fromARGB(255, 125, 26, 255), width: 2),
    ),
  ),

  // Configure elevated button appearance for dark mode
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ButtonStyle(
      animationDuration: const Duration(milliseconds: 200),  // Button press animation duration
      padding: WidgetStateProperty.all(                      // Consistent button padding
        const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
      shape: WidgetStateProperty.all(                        // Rounded button corners
        RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
    ),
  ),
);
```

# lib/util/categorie_filter.dart

```dart
// Widget for filtering items by category with animated chips
import 'package:flutter/material.dart';

// Stateful widget to manage category selection and animations
class CategoryFilter extends StatefulWidget {
  // Currently selected category
  final String selectedCategory;
  
  // Callback function when category changes
  final Function(String) onCategoryChanged;
  
  // List of available categories
  final List<String> categories;

  const CategoryFilter({
    required this.selectedCategory,
    required this.onCategoryChanged,
    required this.categories,
    super.key,
  });

  @override
  State<CategoryFilter> createState() => _CategoryFilterState();
}

// State class with animation capabilities
class _CategoryFilterState extends State<CategoryFilter> with SingleTickerProviderStateMixin {
  // Controller for horizontal scrolling of categories
  late ScrollController _scrollController;
  
  // Controller for entry animations
  late AnimationController _animationController;
  
  @override
  void initState() {
    super.initState();
    // Initialize scroll controller for horizontal scrolling
    _scrollController = ScrollController();
    
    // Setup animation controller for staggered entry
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );
    _animationController.forward();  // Start entry animation
  }

  @override
  void dispose() {
    // Clean up controllers
    _scrollController.dispose();
    _animationController.dispose();
    super.dispose();
  }

  // Automatically scroll to make selected category visible
  void _scrollToSelected() {
    final index = widget.categories.indexOf(widget.selectedCategory);
    if (index != -1) {
      final itemOffset = index * 90.0;  // Estimated width of each category chip
      _scrollController.animateTo(
        itemOffset.clamp(0, _scrollController.position.maxScrollExtent),
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOutCubic,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 50,  // Fixed height for category filter
      child: ShaderMask(
        // Gradient mask for fade effect at edges
        shaderCallback: (Rect bounds) {
          return LinearGradient(
            begin: Alignment.centerLeft,
            end: Alignment.centerRight,
            colors: [
              Colors.white,                    // Solid at edges
              Colors.white.withOpacity(0.1),   // Fade in
              Colors.white.withOpacity(0.1),   // Fade in
              Colors.white,                    // Solid at edges
            ],
            stops: const [0.0, 0.1, 0.9, 1.0],
          ).createShader(bounds);
        },
        blendMode: BlendMode.dstOut,
        child: ListView.builder(
          controller: _scrollController,
          scrollDirection: Axis.horizontal,
          itemCount: widget.categories.length,
          itemBuilder: (context, index) {
            bool isSelected = widget.selectedCategory == widget.categories[index];
            
            // Staggered animation timing based on index
            final double delayFactor = index / widget.categories.length;
            final Animation<double> animation = CurvedAnimation(
              parent: _animationController,
              curve: Interval(
                delayFactor * 0.5,
                (delayFactor * 0.5) + 0.5,
                curve: Curves.easeOutBack,
              ),
            );

            return AnimatedBuilder(
              animation: animation,
              builder: (context, child) {
                // Slide up and fade in animation
                return Transform.translate(
                  offset: Offset(0, 50 * (1 - animation.value)),
                  child: Opacity(
                    opacity: animation.value.clamp(0.0, 1.0),
                    child: child,
                  ),
                );
              },
              child: Padding(
                // Dynamic padding based on position
                padding: EdgeInsets.only(
                  left: index == 0 ? 0 : 8.0,
                  right: index == widget.categories.length - 1 ? 0 : 8.0,
                ),
                child: FilterChip(
                  labelPadding: const EdgeInsets.symmetric(horizontal: 8.0),
                  selectedColor: Theme.of(context).colorScheme.secondary,
                  backgroundColor: Theme.of(context).colorScheme.primary,
                  elevation: isSelected ? 4 : 0,
                  label: Text(
                    widget.categories[index],
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.onPrimary,
                      fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                    ),
                  ),
                  selected: isSelected,
                  onSelected: (_) {
                    widget.onCategoryChanged(widget.categories[index]);
                    // Ensure selected category is visible after selection
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      _scrollToSelected();
                    });
                  },
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}
```

# lib/util/data_tile.dart

```dart
import 'package:flutter/material.dart';

// Widget for displaying animated data with hover effects and transitions
class DataTile extends StatefulWidget {
  // Data to be displayed in the tile
  final String data;
  
  const DataTile({super.key, required this.data});

  @override
  State<DataTile> createState() => _DataTileState();
}

// State class managing animations and interactions
class _DataTileState extends State<DataTile> with SingleTickerProviderStateMixin {
  // Animation controller for coordinating multiple animations
  late AnimationController _controller;
  
  // Fade animation for text transitions
  late Animation<double> _opacityAnimation;
  
  // Scale animation for bounce effect
  late Animation<double> _bounceAnimation;
  
  // Store previous data for smooth transitions
  String? _previousData;
  
  // Track hover state for interaction effects
  bool _isHovered = false;

  @override
  void initState() {
    super.initState();
    // Initialize main animation controller
    _controller = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );

    // Configure fade animation for text
    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: const Interval(0.4, 1.0, curve: Curves.easeIn),
    ));

    // Configure bounce animation sequence
    _bounceAnimation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.0, end: 1.2),
        weight: 1.0,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.2, end: 1.0),
        weight: 1.0,
      ),
    ]).animate(CurvedAnimation(
      parent: _controller,
      curve: const Interval(0.6, 1.0, curve: Curves.easeInOut),
    ));

    // Start initial animation
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  // Handle data updates with animation
  @override
  void didUpdateWidget(DataTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.data != widget.data) {
      _previousData = oldWidget.data;
      _controller.reset();
      _controller.forward();
    }
  }

  @override
  Widget build(BuildContext context) {
    // Responsive width calculation
    final screenWidth = MediaQuery.of(context).size.width;
    final tileWidth = screenWidth < 360 ? 120.0 : 140.0;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return Transform.scale(
            scale: _bounceAnimation.value,
            child: Container(
              // Outer container with hover shadow
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  if (_isHovered)
                    BoxShadow(
                      color: Theme.of(context).colorScheme.primary.withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 4),
                    ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  color: Theme.of(context).colorScheme.primary,
                  height: 60,
                  width: tileWidth,
                  child: Stack(
                    alignment: Alignment.center,
                    children: [
                      // Previous data with fade out animation
                      if (_previousData != null)
                        Opacity(
                          opacity: 1 - _opacityAnimation.value,
                          child: Transform.translate(
                            offset: Offset(0, 20 * _opacityAnimation.value),
                            child: _buildDataText(_previousData!),
                          ),
                        ),
                      // New data with fade in animation
                      Opacity(
                        opacity: _opacityAnimation.value,
                        child: Transform.translate(
                          offset: Offset(0, -20 * (1 - _opacityAnimation.value)),
                          child: _buildDataText(widget.data),
                        ),
                      ),
                      // Hover ripple effect
                      if (_isHovered) _buildRippleEffect(),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  // Build text display with consistent styling
  Widget _buildDataText(String text) {
    return Center(
      child: FittedBox(
        fit: BoxFit.scaleDown,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8.0),
          child: Text(
            text,
            style: TextStyle(
              color: Theme.of(context).colorScheme.onPrimary,
              fontWeight: FontWeight.bold,
              fontSize: 20,
            ),
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
        ),
      ),
    );
  }

  // Build animated hover ripple effect
  Widget _buildRippleEffect() {
    return TweenAnimationBuilder<double>(
      duration: const Duration(milliseconds: 300),
      tween: Tween(begin: 0.0, end: 1.0),
      builder: (context, value, child) {
        return Container(
          decoration: BoxDecoration(
            gradient: RadialGradient(
              colors: [
                Theme.of(context).colorScheme.primary.withOpacity(0.2 * value),
                Colors.transparent,
              ],
              center: Alignment.center,
              radius: 1.5 * value,
            ),
          ),
        );
      },
    );
  }
}
```

# lib/util/dialog_box.dart

```dart
import 'package:flutter/material.dart';
import 'package:Lists/util/my_button.dart';
import 'package:flutter/services.dart';

// Dialog box for creating or editing shopping list items with animations
class DialogBox extends StatefulWidget {
  // Controllers for text input fields
  final TextEditingController nameController;
  final TextEditingController priceController;
  final TextEditingController linkController;
  
  // Callback functions for user actions
  final VoidCallback onSave;
  final VoidCallback onCancel;
  final ValueChanged<String?> onChangedCategory;
  
  // Data for category selection
  final List<String> categories;
  final String selectedCategory;

  const DialogBox({
    super.key,
    required this.nameController,
    required this.priceController,
    required this.linkController,
    required this.onSave,
    required this.onCancel,
    required this.categories,
    required this.selectedCategory,
    required this.onChangedCategory,
  });

  @override
  State<DialogBox> createState() => _DialogBoxState();
}

// State class managing animations and dialog content
class _DialogBoxState extends State<DialogBox> with SingleTickerProviderStateMixin {
  // Animation controllers and animations
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    // Initialize dialog appearance animation
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _scaleAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOutBack,
    );
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return ScaleTransition(
      scale: _scaleAnimation,
      child: AlertDialog(
        backgroundColor: Theme.of(context).colorScheme.surface,
        content: SizedBox(
          height: MediaQuery.of(context).size.height * 0.5,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              // Animated category dropdown
              TweenAnimationBuilder<double>(
                duration: const Duration(milliseconds: 300),
                tween: Tween(begin: 0.0, end: 1.0),
                builder: (context, value, child) {
                  return Opacity(
                    opacity: value,
                    child: Transform.translate(
                      offset: Offset(0, 20 * (1 - value)),
                      child: DropdownButton<String>(
                        dropdownColor: Theme.of(context).colorScheme.surface,
                        value: widget.categories.contains(widget.selectedCategory)
                            ? widget.selectedCategory
                            : widget.categories.first,
                        items: widget.categories.toSet().map((String category) {
                          return DropdownMenuItem<String>(
                            value: category,
                            child: Text(
                              category,
                              style: TextStyle(
                                color: Theme.of(context).colorScheme.onPrimary,
                              ),
                            ),
                          );
                        }).toList(),
                        onChanged: widget.onChangedCategory,
                      ),
                    ),
                  );
                },
              ),

              // Sequentially animated input fields
              ..._buildAnimatedInputFields(),

              // Animated action buttons
              TweenAnimationBuilder<double>(
                duration: const Duration(milliseconds: 300),
                tween: Tween(begin: 0.0, end: 1.0),
                builder: (context, value, child) {
                  return Opacity(
                    opacity: value,
                    child: Transform.translate(
                      offset: Offset(0, 20 * (1 - value)),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          MyButton(text: "Save", onPressed: widget.onSave),
                          const SizedBox(width: 8),
                          MyButton(text: "Cancel", onPressed: widget.onCancel),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Build input fields with staggered animations
  List<Widget> _buildAnimatedInputFields() {
    final fields = [
      _buildInputField(
        controller: widget.nameController,
        hintText: 'Item Name',
      ),
      _buildInputField(
        controller: widget.priceController,
        hintText: 'Item Price',
        inputFormatters: [
          FilteringTextInputFormatter.allow(RegExp(r'^[0-9\.]+$')),
        ],
      ),
      _buildInputField(
        controller: widget.linkController,
        hintText: 'Item Link',
      ),
    ];

    return fields.asMap().entries.map((entry) {
      return TweenAnimationBuilder<double>(
        duration: Duration(milliseconds: 200 + (entry.key * 100)),  // Staggered timing
        tween: Tween(begin: 0.0, end: 1.0),
        builder: (context, value, child) {
          return Opacity(
            opacity: value,
            child: Transform.translate(
              offset: Offset(0, 20 * (1 - value)),
              child: child,
            ),
          );
        },
        child: entry.value,
      );
    }).toList();
  }

  // Build styled input field with consistent appearance
  Widget _buildInputField({
    required TextEditingController controller,
    required String hintText,
    List<TextInputFormatter>? inputFormatters,
  }) {
    return TextField(
      controller: controller,
      style: TextStyle(color: Theme.of(context).colorScheme.onPrimary),
      decoration: InputDecoration(
        border: const OutlineInputBorder(),
        hintText: hintText,
        hintStyle: TextStyle(color: Theme.of(context).colorScheme.onPrimary),
      ),
      inputFormatters: inputFormatters,
    );
  }
}
```

# lib/util/list_tile.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_slidable/flutter_slidable.dart';

// Custom list tile with animations, hover effects, and sliding actions
class MyListTile extends StatefulWidget {
  // Tile content and callback functions
  final String title;
  final GestureTapCallback? onTap;
  final Function(BuildContext)? deleteFunction;

  const MyListTile({
    super.key,
    required this.title,
    required this.onTap,
    required this.deleteFunction,
  });

  @override
  State<MyListTile> createState() => _MyListTileState();
}

// State class managing animations and interactions
class _MyListTileState extends State<MyListTile> 
    with SingleTickerProviderStateMixin {
  // Animation controllers and animations
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<Offset> _slideAnimation;
  
  // Track hover state
  bool _isHovered = false;

  @override
  void initState() {
    super.initState();
    // Initialize main animation controller
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );

    // Configure scale animation for appearance
    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOutBack,
    ));

    // Configure slide animation for entry
    _slideAnimation = Tween<Offset>(
      begin: const Offset(-1.0, 0.0),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOutCubic,
    ));

    // Start initial animation
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return FadeTransition(
          opacity: _controller,
          child: SlideTransition(
            position: _slideAnimation,
            child: ScaleTransition(
              scale: _scaleAnimation,
              child: Padding(
                padding: const EdgeInsets.only(left: 25, right: 25, top: 25),
                child: MouseRegion(
                  onEnter: (_) => setState(() => _isHovered = true),
                  onExit: (_) => setState(() => _isHovered = false),
                  child: Slidable(
                    key: ValueKey(widget.title),
                    endActionPane: ActionPane(
                      motion: const ScrollMotion(),
                      dismissible: DismissiblePane(
                        onDismissed: () => widget.deleteFunction?.call(context),
                        closeOnCancel: true,
                      ),
                      extentRatio: 0.35,
                      children: [
                        _buildDeleteAction(context),
                      ],
                    ),
                    child: _buildTileContent(context),
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  // Build delete action button with animation
  Widget _buildDeleteAction(BuildContext context) {
    return CustomSlidableAction(
      onPressed: widget.deleteFunction,
      backgroundColor: Colors.red.shade300,
      foregroundColor: Theme.of(context).colorScheme.onPrimary,
      borderRadius: const BorderRadius.horizontal(
        left: Radius.circular(12),
        right: Radius.circular(12),
      ),
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return Transform.scale(
            scale: 0.8 + (_controller.value * 0.2),
            child: Icon(
              Icons.delete,
              color: Theme.of(context).colorScheme.onPrimary,
            ),
          );
        },
      ),
    );
  }

  // Build main tile content with hover effects
  Widget _buildTileContent(BuildContext context) {
    return GestureDetector(
      onTap: widget.onTap,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: const EdgeInsets.all(25),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.primary,
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            if (_isHovered)
              BoxShadow(
                color: Theme.of(context).colorScheme.primary.withOpacity(0.3),
                blurRadius: 8,
                offset: const Offset(0, 4),
              ),
          ],
        ),
        child: Row(
          children: [
            // Title text with hover effect
            Expanded(
              child: Text(
                widget.title,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.onPrimary,
                  fontSize: 18,
                  fontWeight: _isHovered ? FontWeight.bold : FontWeight.normal,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            // Animated arrow indicator on hover
            AnimatedOpacity(
              duration: const Duration(milliseconds: 200),
              opacity: _isHovered ? 1.0 : 0.0,
              child: Icon(
                Icons.arrow_forward_ios,
                size: 16,
                color: Theme.of(context).colorScheme.onPrimary,
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

# lib/util/my_button.dart

```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

// Custom button widget with animations, loading state, and customizable appearance
class MyButton extends StatefulWidget {
  // Button properties
  final String text;
  final VoidCallback onPressed;
  final bool isLoading;
  final Color? backgroundColor;
  final Color? textColor;
  final IconData? icon;
  final double? width;
  final double? height;

  const MyButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.backgroundColor,
    this.textColor,
    this.icon,
    this.width,
    this.height,
  });

  @override
  State<MyButton> createState() => _MyButtonState();
}

// State class managing animations and interactions
class _MyButtonState extends State<MyButton> with SingleTickerProviderStateMixin {
  // Animation controller for press effect
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  
  // Interaction states
  bool _isPressed = false;
  bool _isHovered = false;

  @override
  void initState() {
    super.initState();
    // Initialize scale animation for press effect
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 0.95,
    ).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: Curves.easeInOut,
      ),
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  // Handle press interaction states
  void _handleTapDown(TapDownDetails details) {
    setState(() => _isPressed = true);
    _animationController.forward();
  }

  void _handleTapUp(TapUpDetails details) {
    setState(() => _isPressed = false);
    _animationController.reverse();
  }

  void _handleTapCancel() {
    setState(() => _isPressed = false);
    _animationController.reverse();
  }

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: AnimatedBuilder(
        animation: _scaleAnimation,
        builder: (context, child) {
          return Transform.scale(
            scale: _scaleAnimation.value,
            child: Container(
              width: widget.width,
              height: widget.height,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  if (_isHovered && !widget.isLoading)
                    BoxShadow(
                      color: (widget.backgroundColor ?? 
                          Theme.of(context).colorScheme.secondary)
                          .withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 4),
                    ),
                ],
              ),
              child: GestureDetector(
                onTapDown: widget.isLoading ? null : _handleTapDown,
                onTapUp: widget.isLoading ? null : _handleTapUp,
                onTapCancel: _handleTapCancel,
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 150),
                  curve: Curves.easeInOut,
                  child: ElevatedButton(
                    onPressed: widget.isLoading ? null : widget.onPressed,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: widget.backgroundColor ?? 
                          Theme.of(context).colorScheme.secondary,
                      foregroundColor: widget.textColor ?? 
                          Theme.of(context).colorScheme.onSecondary,
                      elevation: _isPressed ? 2 : (_isHovered ? 8 : 4),
                      shadowColor: (widget.backgroundColor ?? 
                          Theme.of(context).colorScheme.secondary)
                          .withOpacity(0.5),
                      padding: const EdgeInsets.symmetric(
                        horizontal: 20,
                        vertical: 12,
                      ),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: AnimatedSize(
                      duration: const Duration(milliseconds: 150),
                      child: widget.isLoading
                          ? _buildLoadingIndicator()
                          : _buildButtonContent(),
                    ),
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  // Build loading spinner widget
  Widget _buildLoadingIndicator() {
    return SizedBox(
      height: 20,
      width: 20,
      child: CircularProgressIndicator(
        strokeWidth: 2,
        valueColor: AlwaysStoppedAnimation<Color>(
          widget.textColor ?? Theme.of(context).colorScheme.onSecondary,
        ),
      ),
    );
  }

  // Build button content with optional icon
  Widget _buildButtonContent() {
    return Row(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        if (widget.icon != null) ...[
          Icon(
            widget.icon,
            size: 18,
            color: widget.textColor ?? Theme.of(context).colorScheme.onSecondary,
          ),
          const SizedBox(width: 8),
        ],
        Text(
          widget.text,
          style: TextStyle(
            color: widget.textColor ?? Theme.of(context).colorScheme.onSecondary,
            fontWeight: FontWeight.bold,
            fontSize: 16,
          ),
        ),
      ],
    );
  }

  // Add diagnostic properties for debugging
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<bool>('isPressed', _isPressed));
    properties.add(DiagnosticsProperty<bool>('isHovered', _isHovered));
  }
}

// Custom splash factory for enhanced touch feedback
class CustomSplashFactory extends InteractiveInkFeatureFactory {
  @override
  InteractiveInkFeature create({
    required MaterialInkController controller,
    required RenderBox referenceBox,
    required Offset position,
    required Color color,
    required TextDirection textDirection,
    bool containedInkWell = false,
    RectCallback? rectCallback,
    BorderRadius? borderRadius,
    ShapeBorder? customBorder,
    double? radius,
    VoidCallback? onRemoved,
  }) {
    return CustomSplash(
      controller: controller,
      referenceBox: referenceBox,
      position: position,
      color: color,
      containedInkWell: containedInkWell,
      rectCallback: rectCallback,
      borderRadius: borderRadius,
      customBorder: customBorder,
      radius: radius,
      onRemoved: onRemoved,
      textDirection: textDirection,
    );
  }
}

// Custom splash animation implementation
class CustomSplash extends InteractiveInkFeature {
  final BorderRadius? borderRadius;
  @override
  final ShapeBorder? customBorder;
  final RectCallback? rectCallback;
  final double? radius;
  @override
  final Color color;
  final TextDirection textDirection;

  CustomSplash({
    required MaterialInkController controller,
    required super.referenceBox,
    required Offset position,
    required this.color,
    required this.textDirection,
    this.containedInkWell = false,
    this.rectCallback,
    this.borderRadius,
    this.customBorder,
    this.radius,
    super.onRemoved,
  }) : super(
          color: color,
          controller: controller,
        ) {
    // Initialize alpha animation for splash effect
    _alphaController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: controller.vsync,
    )..addListener(controller.markNeedsPaint);

    _alphaController.forward();
    _alphaAnimation = _alphaController.drive(Tween(begin: 0.0, end: color.alpha.toDouble()));

    controller.addInkFeature(this);
  }

  late final AnimationController _alphaController;
  late final Animation<double> _alphaAnimation;
  bool containedInkWell = false;

  // Handle splash confirmation
  @override
  void confirm() {
    _alphaController.forward();
  }

  // Handle splash cancellation
  @override
  void cancel() {
    _alphaController.reverse();
  }

  // Clean up resources
  @override
  void dispose() {
    _alphaController.dispose();
    super.dispose();
  }

  // Paint the splash effect
  @override
  void paintFeature(Canvas canvas, Matrix4 transform) {
    final Paint paint = Paint()..color = color.withAlpha(_alphaAnimation.value.toInt());
    final Offset center = referenceBox.size.center(Offset.zero);
    final double finalRadius = radius ?? referenceBox.size.width / 2;
    
    canvas.save();
    canvas.transform(transform.storage);
    
    if (customBorder != null || borderRadius != null) {
      final Rect rect = rectCallback?.call() ?? Offset.zero & referenceBox.size;
      final Path clipPath = Path();
      
      if (customBorder != null) {
        clipPath.addPath(
          customBorder!.getOuterPath(rect, textDirection: textDirection),
          Offset.zero,
        );
      } else if (borderRadius != null) {
        clipPath.addRRect(
          borderRadius!.toRRect(rect),
        );
      }
      
      canvas.clipPath(clipPath);
    }
    
    canvas.drawCircle(center, finalRadius * _alphaAnimation.value, paint);
    canvas.restore();
  }
}
```

# lib/util/my_drawer.dart

```dart
import 'package:Lists/util/list_tile.dart';
import 'package:Lists/util/share_list_dialog.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:Lists/data/firebase_service.dart';

class MyDrawer extends StatefulWidget {
  final List<String> listNames;
  final VoidCallback onCreateNewList;
  final Function(String) onListChange;
  final Function(String) onDeleteList;
  final Function(String) onCurrencyChange;
  final Function(String) onShareList;
  final String currentCurrency;
  final String currentListName;

  const MyDrawer({
    super.key,
    required this.listNames,
    required this.onCreateNewList,
    required this.onListChange,
    required this.onDeleteList,
    required this.onCurrencyChange,
    required this.onShareList,
    required this.currentCurrency,
    required this.currentListName,
  });

  @override
  State<MyDrawer> createState() => _MyDrawerState();
}

class _MyDrawerState extends State<MyDrawer> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late ScrollController _scrollController;
  late FirebaseService _firebaseService;
  
  final user = FirebaseAuth.instance.currentUser;
  bool _mounted = true;
  
  Map<String, String> _displayNameCache = {};
  Map<String, List<String>> _sharedUsersCache = {};
  bool _isLoadingNames = true;
  bool _isInitialized = false;
  
  @override
  void initState() {
    super.initState();
    _initializeServices();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );
    _scrollController = ScrollController();
    _animationController.forward();
  }

  Future<void> _initializeServices() async {
    try {
      _firebaseService = await FirebaseService.create();
      if (_mounted) {
        setState(() => _isInitialized = true);
        await _loadDisplayNames();
        await _loadSharedUsers(widget.currentListName);
      }
    } catch (e) {
      print('Error initializing services: $e');
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    _scrollController.dispose();
    _mounted = false;
    super.dispose();
  }

  @override
  void didUpdateWidget(MyDrawer oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.listNames != widget.listNames) {
      _loadDisplayNames();
    }
    if (oldWidget.currentListName != widget.currentListName) {
      _loadSharedUsers(widget.currentListName);
    }
  }

  Future<void> _loadDisplayNames() async {
    if (!_mounted || !_isInitialized) return;
    
    setState(() => _isLoadingNames = true);
    
    try {
      final names = await _firebaseService.batchLoadListNames(widget.listNames);
      
      if (_mounted) {
        setState(() {
          _displayNameCache = names;
          _isLoadingNames = false;
        });
      }
    } catch (e) {
      print('Error loading display names: $e');
      if (_mounted) {
        setState(() => _isLoadingNames = false);
      }
    }
  }

  Future<void> _loadSharedUsers(String listName) async {
    if (!_mounted || !_isInitialized) return;

    try {
      final docSnapshot = await FirebaseFirestore.instance
          .collection('lists')
          .doc(user?.uid)
          .collection('userLists')
          .doc(listName)
          .get();

      if (!docSnapshot.exists || !_mounted) return;

      final data = docSnapshot.data();
      final List<String> sharedWithIds = List<String>.from(data?['sharedWith'] ?? []);
      
      final List<String> sharedEmails = [];
      final futures = sharedWithIds.map((userId) => FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .get());
          
      final userDocs = await Future.wait(futures);
      
      for (final doc in userDocs) {
        if (doc.exists) {
          final email = doc.data()?['email'] as String?;
          if (email != null) sharedEmails.add(email);
        }
      }

      if (_mounted) {
        setState(() {
          _sharedUsersCache[listName] = sharedEmails;
        });
      }
    } catch (e) {
      print('Error loading shared users: $e');
    }
  }

  Future<void> _handleLogout() async {
    try {
      await _firebaseService.cleanup();
      final navigator = Navigator.of(context);
      await FirebaseAuth.instance.signOut();
      navigator.pop();
    } catch (e) {
      print('Error during logout: $e');
    }
  }

  void _showShareDialog(BuildContext context) async {
    await _loadSharedUsers(widget.currentListName);
    
    if (!mounted) return;
    
    Navigator.pop(context);
    
    showDialog(
      context: context,
      builder: (context) => ShareListDialog(
        listName: _displayNameCache[widget.currentListName] ?? widget.currentListName,
        onShare: _handleShare,
        currentlySharedWith: _sharedUsersCache[widget.currentListName],
      ),
    );
  }

  Future<void> _handleShare(String email) async {
    try {
      await widget.onShareList(email);
      await _loadSharedUsers(widget.currentListName);
    } catch (e) {
      rethrow;
    }
  }

  void _showDeleteConfirmation(BuildContext context, String listName) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: Theme.of(context).colorScheme.surface,
        title: Text(
          'Delete List',
          style: TextStyle(
            color: Theme.of(context).colorScheme.onSurface,
            fontWeight: FontWeight.bold,
          ),
        ),
        content: Text(
          'Are you sure you want to delete "${_displayNameCache[listName] ?? listName}"?',
          style: TextStyle(
            color: Theme.of(context).colorScheme.onSurface,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(
              'Cancel',
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSurface,
              ),
            ),
          ),
          TextButton(
            onPressed: () async {
              widget.onDeleteList(listName);
              Navigator.pop(context);
              Navigator.pop(context);
              if (_isInitialized) {
                await _firebaseService.clearNameCache();
              }
            },
            child: Text(
              'Delete',
              style: TextStyle(
                color: Theme.of(context).colorScheme.error,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        elevation: 24,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Drawer(
      backgroundColor: Theme.of(context).colorScheme.surface,
      child: Column(
        children: [
          _buildDrawerHeader(context),
          _buildCurrencySelector(context),
          const Divider(height: 1),
          Expanded(
            child: ListView(
              controller: _scrollController,
              padding: EdgeInsets.zero,
              children: _buildListTiles(),
            ),
          ),
          _buildBottomButtons(context),
        ],
      ),
    );
  }

  Widget _buildDrawerHeader(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        final headerAnimation = CurvedAnimation(
          parent: _animationController,
          curve: Curves.easeOut,
        );

        return Transform.translate(
          offset: Offset(-300 * (1 - headerAnimation.value), 0),
          child: Opacity(
            opacity: headerAnimation.value,
            child: Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primary,
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: SafeArea(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const SizedBox(height: 12),
                    Center(
                      child: Column(
                        children: [
                          Icon(
                            Icons.shopping_cart,
                            size: 48,
                            color: Theme.of(context).colorScheme.onPrimary,
                          ),
                          const SizedBox(height: 12),
                          Text(
                            'Shopping Lists',
                            style: TextStyle(
                              color: Theme.of(context).colorScheme.onPrimary,
                              fontSize: 24,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 24),
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Signed in as:',
                          style: TextStyle(
                            color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.7),
                            fontSize: 12,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          user?.email ?? 'Unknown User',
                          style: TextStyle(
                            color: Theme.of(context).colorScheme.onPrimary,
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildBottomButtons(BuildContext context) {
    return Column(
      children: [
        ListTile(
          leading: Icon(
            Icons.share,
            color: Theme.of(context).colorScheme.onSurface,
          ),
          title: Text(
            'Share Current List',
            style: TextStyle(
              color: Theme.of(context).colorScheme.onSurface,
            ),
          ),
          trailing: _sharedUsersCache[widget.currentListName]?.isNotEmpty == true
              ? Badge(
                  backgroundColor: Theme.of(context).colorScheme.secondary,
                  label: Text(
                    _sharedUsersCache[widget.currentListName]!.length.toString(),
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.onSecondary,
                    ),
                  ),
                )
              : null,
          onTap: () => _showShareDialog(context),
        ),
        ListTile(
          leading: Icon(
            Icons.add,
            color: Theme.of(context).colorScheme.onSurface,
          ),
          title: Text(
            'Create New List',
            style: TextStyle(
              color: Theme.of(context).colorScheme.onSurface,
            ),
          ),
          onTap: () {
            Navigator.pop(context);
            widget.onCreateNewList();
          },
        ),
        ListTile(
          leading: Icon(
            Icons.logout,
            color: Theme.of(context).colorScheme.error,
          ),
          title: Text(
            'Logout',
            style: TextStyle(
              color: Theme.of(context).colorScheme.error,
            ),
          ),
          onTap: _handleLogout,
        ),
        const SizedBox(height: 20),
      ],
    );
  }

  Widget _buildCurrencySelector(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        final currencyAnimation = CurvedAnimation(
          parent: _animationController,
          curve: const Interval(0.2, 0.8, curve: Curves.easeOut),
        );

        return Transform.translate(
          offset: Offset(-300 * (1 - currencyAnimation.value), 0),
          child: Opacity(
            opacity: currencyAnimation.value,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Currency',
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.onSurface,
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Container(
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        _buildCurrencyOption(context, '€'),
                        Container(
                          width: 1,
                          height: 24,
                          color: Theme.of(context).colorScheme.onSurface.withOpacity(0.2),
                        ),
                        _buildCurrencyOption(context, '\$'),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildCurrencyOption(BuildContext context, String currency) {
    final isSelected = widget.currentCurrency == currency;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () => widget.onCurrencyChange(currency),
        borderRadius: BorderRadius.circular(8),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
          decoration: BoxDecoration(
            color: isSelected 
                ? Theme.of(context).colorScheme.secondary
                : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Text(
            currency,
            style: TextStyle(
              color: isSelected
                  ? Theme.of(context).colorScheme.onSecondary
                  : Theme.of(context).colorScheme.onSurface,
              fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
            ),
          ),
        ),
      ),
    );
  }

  List<Widget> _buildListTiles() {
    return widget.listNames.asMap().entries.map((entry) {
      final index = entry.key;
      final listId = entry.value;
      final displayName = _displayNameCache[listId] ?? listId;
      
      final Animation<double> animation = CurvedAnimation(
        parent: _animationController,
        curve: Interval(
          0.2 + (index / widget.listNames.length) * 0.5,
          0.2 + ((index + 1) / widget.listNames.length) * 0.5,
          curve: Curves.easeOutCubic,
        ),
      );

      return AnimatedBuilder(
        animation: animation,
        builder: (context, child) {
          return Transform.translate(
            offset: Offset(300 * (1 - animation.value), 0),
            child: Opacity(
              opacity: animation.value,
              child: child,
            ),
          );
        },
        child: _isLoadingNames && !_displayNameCache.containsKey(listId)
            ? _buildLoadingTile()
            : MyListTile(
                title: displayName,
                onTap: () {
                  widget.onListChange(listId);
                  Navigator.pop(context);
                },
                deleteFunction: (context) {
                  _showDeleteConfirmation(context, listId);
                },
              ),
      );
    }).toList();
  }

  Widget _buildLoadingTile() {
    return Padding(
      padding: const EdgeInsets.only(left: 25, right: 25, top: 25),
      child: Container(
        height: 80,
        padding: const EdgeInsets.all(25),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.primary.withOpacity(0.5),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Center(
          child: SizedBox(
            height: 20,
            width: 20,
            child: CircularProgressIndicator(
              strokeWidth: 2,
              valueColor: AlwaysStoppedAnimation<Color>(
                Theme.of(context).colorScheme.onPrimary,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

# lib/util/my_reorderable_list_view.dart

```dart
import 'package:flutter/material.dart';

// Custom reorderable list view with scrolling behavior
class CustomReorderableListView extends StatelessWidget {
  // Builder function to create list items
  final IndexedWidgetBuilder itemBuilder;
  
  // Total number of items in the list
  final int itemCount;
  
  // Callback function when items are reordered
  final void Function(int, int) onReorder;

  const CustomReorderableListView({
    super.key,
    required this.itemBuilder,
    required this.itemCount,
    required this.onReorder,
  });

  @override
  Widget build(BuildContext context) {
    return ReorderableListView.builder(
      // Disable default drag handles for custom implementation
      buildDefaultDragHandles: false,
      
      // Use provided builder function for list items
      itemBuilder: itemBuilder,
      itemCount: itemCount,
      
      // Handle reordering with provided callback
      onReorder: onReorder,
      
      // Remove default drag animation decoration
      proxyDecorator: (child, index, animation) {
        return child; // Return unmodified child widget
      },
      
      // Use default scroll physics for natural scrolling
      physics: const AlwaysScrollableScrollPhysics(),
      
      // Add padding at the bottom for better UX
      padding: const EdgeInsets.only(bottom: 100),
    );
  }
}
```

# lib/util/share_list_dialog.dart

```dart
import 'package:flutter/material.dart';
import 'package:Lists/util/my_button.dart';

class ShareListDialog extends StatefulWidget {
  final String listName;
  final Function(String email) onShare;
  final List<String>? currentlySharedWith; // Optional, falls noch nicht implementiert

  const ShareListDialog({
    super.key,
    required this.listName,
    required this.onShare,
    this.currentlySharedWith,
  });

  @override
  State<ShareListDialog> createState() => _ShareListDialogState();
}

class _ShareListDialogState extends State<ShareListDialog> with SingleTickerProviderStateMixin {
  final _emailController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  bool _isLoading = false;
  String? _errorMessage;
  
  // Animation Controller für neue Elemente
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    
    _fadeAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );

    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  Future<void> _shareList() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final email = _emailController.text.trim();
      
      // Prüfen ob die Liste bereits geteilt wurde
      if (widget.currentlySharedWith?.contains(email) ?? false) {
        throw Exception('List is already shared with this user');
      }

      await widget.onShare(email);
      if (mounted) {
        Navigator.of(context).pop();
      }
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: Theme.of(context).colorScheme.surface,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      title: Text(
        'Share "${widget.listName}"',
        style: TextStyle(
          color: Theme.of(context).colorScheme.onSurface,
          fontWeight: FontWeight.bold,
        ),
      ),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Form(
              key: _formKey,
              child: TextFormField(
                controller: _emailController,
                decoration: InputDecoration(
                  labelText: 'Email Address',
                  hintText: 'example@email.com',
                  prefixIcon: Icon(
                    Icons.email,
                    color: Theme.of(context).colorScheme.onSurface.withOpacity(0.7),
                  ),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide(
                      color: Theme.of(context).colorScheme.onSurface.withOpacity(0.3),
                    ),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide(
                      color: Theme.of(context).colorScheme.secondary,
                      width: 2,
                    ),
                  ),
                ),
                style: TextStyle(
                  color: Theme.of(context).colorScheme.onSurface,
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter an email address';
                  }
                  if (!value.contains('@')) {
                    return 'Please enter a valid email address';
                  }
                  if (widget.currentlySharedWith?.contains(value) ?? false) {
                    return 'List is already shared with this user';
                  }
                  return null;
                },
                keyboardType: TextInputType.emailAddress,
                textInputAction: TextInputAction.done,
                onFieldSubmitted: (_) => _shareList(),
              ),
            ),
            if (_errorMessage != null)
              Padding(
                padding: const EdgeInsets.only(top: 8),
                child: Text(
                  _errorMessage!,
                  style: TextStyle(
                    color: Theme.of(context).colorScheme.error,
                    fontSize: 12,
                  ),
                ),
              ),
            
            // Zeige aktuell geteilte Benutzer an
            if (widget.currentlySharedWith != null && 
                widget.currentlySharedWith!.isNotEmpty)
              FadeTransition(
                opacity: _fadeAnimation,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const SizedBox(height: 16),
                    Text(
                      'Currently shared with:',
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.onSurface,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ...widget.currentlySharedWith!.map((email) => 
                      Card(
                        color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
                        child: Padding(
                          padding: const EdgeInsets.all(8.0),
                          child: Row(
                            children: [
                              Icon(
                                Icons.person,
                                size: 20,
                                color: Theme.of(context).colorScheme.onSurface,
                              ),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  email,
                                  style: TextStyle(
                                    color: Theme.of(context).colorScheme.onSurface,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(
            'Cancel',
            style: TextStyle(
              color: Theme.of(context).colorScheme.onSurface,
            ),
          ),
        ),
        MyButton(
          text: 'Share',
          onPressed: _shareList,
          isLoading: _isLoading,
          backgroundColor: Theme.of(context).colorScheme.secondary,
          textColor: Theme.of(context).colorScheme.onSecondary,
        ),
      ],
    );
  }
}
```

# lib/util/shopping_tile.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_slidable/flutter_slidable.dart';
import 'package:Lists/util/dialog_box.dart';
import 'package:url_launcher/url_launcher.dart';

// Interactive shopping list item with animations and slidable actions
class ShoppingTile extends StatefulWidget {
  // Item properties
  final String productName;
  final String productPrice;
  final String productLink;
  final String currency;
  
  // Controllers for editing
  final TextEditingController nameController;
  final TextEditingController priceController;
  final TextEditingController linkController;
  
  // Category management
  final List<String> categories;
  final String selectedCategory;
  final ValueChanged<String?> onChangedCategory;
  
  // Item management
  final int index;
  final Function(BuildContext)? deleteFunction;
  final Function(BuildContext)? editFunction;

  const ShoppingTile({
    super.key,
    required this.productName,
    required this.productPrice,
    required this.productLink,
    required this.currency,
    required this.nameController,
    required this.priceController,
    required this.linkController,
    required this.categories,
    required this.selectedCategory,
    required this.index,
    required this.deleteFunction,
    required this.editFunction,
    required this.onChangedCategory,
  });

  @override
  State<ShoppingTile> createState() => _ShoppingTileState();
}

class _ShoppingTileState extends State<ShoppingTile>
    with SingleTickerProviderStateMixin {
  // Animation controllers and animations
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _slideAnimation;
  late Animation<double> _opacityAnimation;
  
  // State tracking
  bool _isHovered = false;
  bool _isDragging = false;

  @override
  void initState() {
    super.initState();
    // Initialize animation controller
    _controller = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );

    // Setup scale animation for appearance
    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: const Interval(0.0, 0.6, curve: Curves.easeOutBack),
    ));

    // Setup slide animation for entry
    _slideAnimation = Tween<double>(
      begin: 100.0,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: const Interval(0.2, 0.8, curve: Curves.easeOutCubic),
    ));

    // Setup opacity animation for fade in
    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: const Interval(0.4, 1.0, curve: Curves.easeIn),
    ));

    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  // Handle URL launching for product link
  Future<void> _launchUrl(BuildContext context) async {
  String urlString = widget.productLink.trim();
  
  // Füge http:// hinzu, wenn kein Protokoll angegeben ist
  if (!urlString.startsWith('http://') && !urlString.startsWith('https://')) {
    urlString = 'https://$urlString';
  }
  
  try {
    final Uri url = Uri.parse(urlString);
    if (await canLaunchUrl(url)) {
      await launchUrl(
        url,
        mode: LaunchMode.externalApplication,  // Öffnet im externen Browser
      );
    } else {
      _showError(context, 'Could not open link: Invalid URL');
    }
  } catch (e) {
    _showError(context, 'Could not open link: ${e.toString()}');
  }
}

  // Display error when URL launch fails
  void _showError(BuildContext context, String message) {
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      behavior: SnackBarBehavior.floating,
      backgroundColor: Colors.red,
      duration: const Duration(seconds: 3),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10),
      ),
      action: SnackBarAction(
        label: 'OK',
        textColor: Colors.white,
        onPressed: () {
          ScaffoldMessenger.of(context).hideCurrentSnackBar();
        },
      ),
    ),
  );
}

  // Format price with currency conversion
  String _formatPrice() {
    String price = widget.productPrice.replaceAll(RegExp(r'[€$]'), '');
    String originalCurrency = widget.productPrice.contains('€') ? '€' : '\$';
    
    if (originalCurrency == widget.currency) {
      return '${double.parse(price).toStringAsFixed(2)}${widget.currency}';
    }
    
    double rate = (originalCurrency == '€') ? 1 / 0.85 : 0.85;
    double convertedPrice = double.parse(price) * rate;
    
    return '${convertedPrice.toStringAsFixed(2)}${widget.currency}';
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Transform.translate(
          offset: Offset(0, _slideAnimation.value),
          child: Opacity(
            opacity: _opacityAnimation.value,
            child: Transform.scale(
              scale: _scaleAnimation.value,
              child: MouseRegion(
                onEnter: (_) => setState(() => _isHovered = true),
                onExit: (_) => setState(() => _isHovered = false),
                child: _buildSlidableContent(context),
              ),
            ),
          ),
        );
      },
    );
  }

  // Build slidable container with actions
  Widget _buildSlidableContent(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(left: 25, right: 25, top: 25),
      child: Slidable(
        key: ValueKey(widget.productName),
        startActionPane: ActionPane(
          motion: const ScrollMotion(),
          extentRatio: 0.225,
          children: [_buildEditAction(context)],
        ),
        endActionPane: ActionPane(
          motion: const ScrollMotion(),
          dismissible: DismissiblePane(
            onDismissed: () => widget.deleteFunction?.call(context),
            closeOnCancel: true,
          ),
          extentRatio: 0.225,
          children: [_buildDeleteAction(context)],
        ),
        child: _buildMainContent(context),
      ),
    );
  }

  // Build main tile content
  Widget _buildMainContent(BuildContext context) {
    return GestureDetector(
      onDoubleTap: () => _launchUrl(context),
      child: Container(
        height: 80,
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 15),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.primary,
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            if (_isHovered || _isDragging)
              BoxShadow(
                color: Theme.of(context).colorScheme.primary.withOpacity(0.3),
                blurRadius: 8,
                offset: const Offset(0, 4),
              ),
          ],
        ),
        child: Row(
          children: [
            ReorderableDragStartListener(
              index: widget.index,
              child: Icon(
                Icons.drag_handle,
                color: Theme.of(context).colorScheme.onPrimary.withOpacity(
                      _isHovered ? 1.0 : 0.5,
                    ),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 2,
              child: _buildAnimatedText(
                widget.productName,
                TextStyle(
                  color: Theme.of(context).colorScheme.onPrimary,
                  fontSize: 20,
                  fontWeight: _isHovered ? FontWeight.bold : FontWeight.normal,
                ),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 1,
              child: _buildAnimatedPrice(),
            ),
          ],
        ),
      ),
    );
  }

  // Build animated text with hover effect
  Widget _buildAnimatedText(String text, TextStyle style, {TextAlign? textAlign}) {
    return TweenAnimationBuilder<double>(
      duration: const Duration(milliseconds: 200),
      tween: Tween(begin: 0.0, end: _isHovered ? 1.0 : 0.0),
      builder: (context, value, child) {
        return Transform.translate(
          offset: Offset(10 * value, 0),
          child: Text(
            text,
            style: style,
            textAlign: textAlign,
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
        );
      },
    );
  }

  // Build animated price display
  Widget _buildAnimatedPrice() {
    return TweenAnimationBuilder<double>(
      duration: const Duration(milliseconds: 300),
      tween: Tween(begin: 0.0, end: 1.0),
      builder: (context, value, child) {
        return Transform.scale(
          scale: 0.8 + (0.2 * value),
          child: Text(
            _formatPrice(),
            style: TextStyle(
              color: Theme.of(context).colorScheme.onPrimary,
              fontWeight: FontWeight.bold,
              fontSize: 20,
            ),
            textAlign: TextAlign.right,
            overflow: TextOverflow.ellipsis,
          ),
        );
      },
    );
  }

  // Build edit action button
  Widget _buildEditAction(BuildContext context) {
    return CustomSlidableAction(
      onPressed: (context) => showDialog(
        context: context,
        builder: (context) {
          widget.nameController.text = widget.productName;
          widget.priceController.text = widget.productPrice;
          widget.linkController.text = widget.productLink;

          return DialogBox(
            nameController: widget.nameController,
            priceController: widget.priceController,
            linkController: widget.linkController,
            categories: widget.categories,
            selectedCategory: widget.selectedCategory,
            onChangedCategory: widget.onChangedCategory,
            onSave: () {
              widget.editFunction!(context);
              Navigator.of(context).pop();
            },
            onCancel: () => Navigator.of(context).pop(),
          );
        },
      ),
      backgroundColor: Colors.yellow.shade300,
      foregroundColor: Theme.of(context).colorScheme.onPrimary,
      borderRadius: const BorderRadius.horizontal(
        left: Radius.circular(12),
        right: Radius.circular(12),
      ),
      child: const Icon(Icons.edit),
    );
  }

  // Build delete action button
  Widget _buildDeleteAction(BuildContext context) {
    return CustomSlidableAction(
      onPressed: widget.deleteFunction,
      backgroundColor: Colors.red.shade300,
      foregroundColor: Theme.of(context).colorScheme.onPrimary,
      borderRadius: const BorderRadius.horizontal(
        left: Radius.circular(12),
        right: Radius.circular(12),
      ),
      child: _buildDeleteActionContent(),
    );
  }

  // Build animated delete icon
  Widget _buildDeleteActionContent() {
    return TweenAnimationBuilder<double>(
      duration: const Duration(milliseconds: 200),
      tween: Tween(begin: 1.0, end: _isHovered ? 1.2 : 1.0),
      builder: (context, scale, child) {
        return Transform.scale(
          scale: scale,
          child: Icon(
            Icons.delete,
            color: Theme.of(context).colorScheme.onPrimary,
          ),
        );
      },
    );
  }

  // Handle drag start animation
  void startDrag() {
    setState(() => _isDragging = true);
    _controller.repeat(
      reverse: true,
      period: const Duration(milliseconds: 800),
    );
  }

  // Handle drag end animation
  void endDrag() {
    setState(() => _isDragging = false);
    _controller.forward(from: 0.0);
  }
}
```

# LICENSE

```
MIT License

Copyright (c) 2024 Mika Königsmann

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

# lists_application.iml

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/lib" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/test" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/.dart_tool" />
      <excludeFolder url="file://$MODULE_DIR$/.idea" />
      <excludeFolder url="file://$MODULE_DIR$/build" />
    </content>
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="Dart SDK" level="project" />
    <orderEntry type="library" name="Flutter Plugins" level="project" />
    <orderEntry type="library" name="Dart Packages" level="project" />
  </component>
</module>

```

# pubspec.lock

```lock
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: f256b0c0ba6c7577c15e2e4e114755640a875e885099367bf6e012b19314c834
      url: "https://pub.dev"
    source: hosted
    version: "72.0.0"
  _flutterfire_internals:
    dependency: transitive
    description:
      name: _flutterfire_internals
      sha256: "5534e701a2c505fed1f0799e652dd6ae23bd4d2c4cf797220e5ced5764a7c1c2"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.44"
  _macros:
    dependency: transitive
    description: dart
    source: sdk
    version: "0.3.2"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: b652861553cd3990d8ed361f7979dc6d7053a9ac8843fa73820ab68ce5410139
      url: "https://pub.dev"
    source: hosted
    version: "6.7.0"
  args:
    dependency: transitive
    description:
      name: args
      sha256: bf9f5caeea8d8fe6721a9c358dd8a5c1947b27f1cfaa18b39c301273594919e6
      url: "https://pub.dev"
    source: hosted
    version: "2.6.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "947bfcf187f74dbc5e146c9eb9c0f10c9f8b30743e341481c1e2ed3ecc18c20c"
      url: "https://pub.dev"
    source: hosted
    version: "2.11.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "6cfb5af12253eaf2b368f07bacc5a80d1301a071c73360d746b7f2e32d762c66"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  build:
    dependency: transitive
    description:
      name: build
      sha256: "80184af8b6cb3e5c1c4ec6d8544d27711700bc3e6d2efad04238c7b5290889f0"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  build_config:
    dependency: transitive
    description:
      name: build_config
      sha256: bf80fcfb46a29945b423bd9aad884590fb1dc69b330a4d4700cac476af1708d1
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  build_daemon:
    dependency: transitive
    description:
      name: build_daemon
      sha256: "79b2aef6ac2ed00046867ed354c88778c9c0f029df8a20fe10b5436826721ef9"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.2"
  build_resolvers:
    dependency: transitive
    description:
      name: build_resolvers
      sha256: "339086358431fa15d7eca8b6a36e5d783728cf025e559b834f4609a1fcfb7b0a"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  build_runner:
    dependency: "direct dev"
    description:
      name: build_runner
      sha256: "028819cfb90051c6b5440c7e574d1896f8037e3c96cf17aaeb054c9311cfbf4d"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.13"
  build_runner_core:
    dependency: transitive
    description:
      name: build_runner_core
      sha256: f8126682b87a7282a339b871298cc12009cb67109cfa1614d6436fb0289193e0
      url: "https://pub.dev"
    source: hosted
    version: "7.3.2"
  built_collection:
    dependency: transitive
    description:
      name: built_collection
      sha256: "376e3dd27b51ea877c28d525560790aee2e6fbb5f20e2f85d5081027d94e2100"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  built_value:
    dependency: transitive
    description:
      name: built_value
      sha256: c7913a9737ee4007efedaffc968c049fd0f3d0e49109e778edc10de9426005cb
      url: "https://pub.dev"
    source: hosted
    version: "8.9.2"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: "04a925763edad70e8443c99234dc3328f442e811f1d8fd1a72f1c8ad0f69a605"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: feb6bed21949061731a7a75fc5d2aa727cf160b91af9a3e464c5e3a32e28b5ff
      url: "https://pub.dev"
    source: hosted
    version: "2.0.3"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: cb6d7f03e1de671e34607e909a7213e31d7752be4fb66a86d29fe1eb14bfb5cf
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  cloud_firestore:
    dependency: "direct main"
    description:
      name: cloud_firestore
      sha256: bdc7607e9169ee3ce736bbbe6a81c2a6cb15c41379346b74f77f8e641211a17f
      url: "https://pub.dev"
    source: hosted
    version: "5.4.4"
  cloud_firestore_platform_interface:
    dependency: transitive
    description:
      name: cloud_firestore_platform_interface
      sha256: "884fa34c6be2d9c7c1f4af86f90f36c0a3b3afef585a12b350a5d15368e7ec7a"
      url: "https://pub.dev"
    source: hosted
    version: "6.4.3"
  cloud_firestore_web:
    dependency: transitive
    description:
      name: cloud_firestore_web
      sha256: "6e621bbcc999f32db0bc6bfcb18d9991617ec20f8d6bf51b6a1571f5c324fafd"
      url: "https://pub.dev"
    source: hosted
    version: "4.3.2"
  code_builder:
    dependency: transitive
    description:
      name: code_builder
      sha256: f692079e25e7869c14132d39f223f8eec9830eb76131925143b2129c4bb01b37
      url: "https://pub.dev"
    source: hosted
    version: "4.10.0"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: ee67cb0715911d28db6bf4af1026078bd6f0128b07a5f66fb2ed94ec6783c09a
      url: "https://pub.dev"
    source: hosted
    version: "1.18.0"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: "1e445881f28f22d6140f181e07737b22f1e099a5e1ff94b0af2f9e4a463f4855"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.6"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "7856d364b589d1f08986e140938578ed36ed948581fbc3bc9aef1805039ac5ab"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.7"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "511392330127add0b769b75a987850d136345d9227c6b94c96a04cf4a391bf78"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.1"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "16ed7b077ef01ad6170a3d0c57caa4a112a38d7a2ed5602e0aca9ca6f3d98da6"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  firebase_auth:
    dependency: "direct main"
    description:
      name: firebase_auth
      sha256: d453acec0d958ba0e25d41a9901b32cb77d1535766903dea7a61b2788c304596
      url: "https://pub.dev"
    source: hosted
    version: "5.3.1"
  firebase_auth_platform_interface:
    dependency: transitive
    description:
      name: firebase_auth_platform_interface
      sha256: "78966c2ef774f5bf2a8381a307222867e9ece3509110500f7a138c115926aa65"
      url: "https://pub.dev"
    source: hosted
    version: "7.4.7"
  firebase_auth_web:
    dependency: transitive
    description:
      name: firebase_auth_web
      sha256: "77ad3b252badedd3f08dfa21a4c7fe244be96c6da3a4067f253b13ea5d32424c"
      url: "https://pub.dev"
    source: hosted
    version: "5.13.2"
  firebase_core:
    dependency: "direct main"
    description:
      name: firebase_core
      sha256: "51dfe2fbf3a984787a2e7b8592f2f05c986bfedd6fdacea3f9e0a7beb334de96"
      url: "https://pub.dev"
    source: hosted
    version: "3.6.0"
  firebase_core_platform_interface:
    dependency: transitive
    description:
      name: firebase_core_platform_interface
      sha256: e30da58198a6d4b49d5bce4e852f985c32cb10db329ebef9473db2b9f09ce810
      url: "https://pub.dev"
    source: hosted
    version: "5.3.0"
  firebase_core_web:
    dependency: transitive
    description:
      name: firebase_core_web
      sha256: f967a7138f5d2ffb1ce15950e2a382924239eaa521150a8f144af34e68b3b3e5
      url: "https://pub.dev"
    source: hosted
    version: "2.18.1"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "3f41d009ba7172d5ff9be5f6e6e6abb4300e263aab8866d2a0842ed2a70f8f0c"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  flutter_slidable:
    dependency: "direct main"
    description:
      name: flutter_slidable
      sha256: "2c5611c0b44e20d180e4342318e1bbc28b0a44ad2c442f5df16962606fd3e8e3"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.1"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  frontend_server_client:
    dependency: transitive
    description:
      name: frontend_server_client
      sha256: f64a0333a82f30b0cca061bc3d143813a486dc086b574bfb233b7c1372427694
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: "0e7014b3b7d4dac1ca4d6114f82bf1782ee86745b9b42a92c9289c23d8a0ab63"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  graphs:
    dependency: transitive
    description:
      name: graphs
      sha256: "741bbf84165310a68ff28fe9e727332eef1407342fca52759cb21ad8177bb8d0"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  hive:
    dependency: transitive
    description:
      name: hive
      sha256: "8dcf6db979d7933da8217edcec84e9df1bdb4e4edc7fc77dbd5aa74356d6d941"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.3"
  hive_generator:
    dependency: "direct dev"
    description:
      name: hive_generator
      sha256: "06cb8f58ace74de61f63500564931f9505368f45f98958bd7a6c35ba24159db4"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  http_multi_server:
    dependency: transitive
    description:
      name: http_multi_server
      sha256: "97486f20f9c2f7be8f514851703d0119c3596d14ea63227af6f7a481ef2b2f8b"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "2aa08ce0341cc9b354a498388e30986515406668dbcc4f7c950c3e715496693b"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.2"
  io:
    dependency: transitive
    description:
      name: io
      sha256: "2ec25704aba361659e10e3e5f5d672068d332fc8ac516421d483a11e5cbd061e"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.4"
  js:
    dependency: transitive
    description:
      name: js
      sha256: c1b2e9b5ea78c45e1a0788d29606ba27dc5f71f019f32ca5140f61ef071838cf
      url: "https://pub.dev"
    source: hosted
    version: "0.7.1"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: "1ce844379ca14835a50d2f019a3099f419082cfdd231cd86a142af94dd5c6bb1"
      url: "https://pub.dev"
    source: hosted
    version: "4.9.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "3f87a60e8c63aecc975dda1ceedbc8f24de75f09e4856ea27daf8958f2f0ce05"
      url: "https://pub.dev"
    source: hosted
    version: "10.0.5"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "932549fb305594d82d7183ecd9fa93463e9914e1b67cacc34bc40906594a1806"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.5"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "6ba465d5d76e67ddf503e1161d1f4a6bc42306f9d66ca1e8f079a47290fb06d3"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: "976c774dd944a42e83e2467f4cc670daef7eed6295b10b36ae8c85bcbf828235"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  macros:
    dependency: transitive
    description:
      name: macros
      sha256: "0acaed5d6b7eab89f63350bccd82119e6c602df0f391260d0e32b5e23db79536"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.2-main.4"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: d2323aa2060500f906aa31a895b4030b6da3ebdcc5619d14ce1aada65cd161cb
      url: "https://pub.dev"
    source: hosted
    version: "0.12.16+1"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: bdb68674043280c3428e9ec998512fb681678676b3c54e773629ffe74419f8c7
      url: "https://pub.dev"
    source: hosted
    version: "1.15.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: "1c5b77ccc91e4823a5af61ee74e6b972db1ef98c2ff5a18d3161c982a55448bd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "087ce49c3f0dc39180befefc60fdb4acd8f8620e5682fe2476afd0b3688bb4af"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.0"
  path_provider:
    dependency: "direct main"
    description:
      name: path_provider
      sha256: fec0d61223fba3154d87759e3cc27fe2c8dc498f6386c6d6fc80d1afdd1bf378
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: c464428172cb986b758c6d1724c603097febb8fb855aa265aeecc9280c294d4a
      url: "https://pub.dev"
    source: hosted
    version: "2.2.12"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: f234384a3fdd67f989b4d54a5d73ca2a6c422fa55ae694381ae0f4375cd1ea16
      url: "https://pub.dev"
    source: hosted
    version: "2.4.0"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "20fe868b6314b322ea036ba325e6fc0711a22948856475e2c2b6306e8ab39c2a"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.1"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "40d3ab1bbd474c4c2328c91e3a7df8c6dd629b79ece4c4bd04bee496a224fb0c"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  pubspec_parse:
    dependency: transitive
    description:
      name: pubspec_parse
      sha256: c799b721d79eb6ee6fa56f00c04b472dcd44a30d258fac2174a6ec57302678f8
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  shared_preferences:
    dependency: "direct main"
    description:
      name: shared_preferences
      sha256: "746e5369a43170c25816cc472ee016d3a66bc13fcf430c0bc41ad7b4b2922051"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      sha256: "3b9febd815c9ca29c9e3520d50ec32f49157711e143b7a4ca039eb87e8ade5ab"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.3"
  shared_preferences_foundation:
    dependency: transitive
    description:
      name: shared_preferences_foundation
      sha256: "07e050c7cd39bad516f8d64c455f04508d09df104be326d8c02551590a0d513d"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.3"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      sha256: "580abfd40f415611503cae30adf626e6656dfb2f0cee8f465ece7b6defb40f2f"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      sha256: "57cbf196c486bc2cf1f02b85784932c6094376284b3ad5779d1b1c6c6a816b80"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      sha256: d2ca4132d3946fec2184261726b355836a82c33d7d5b67af32692aff18a4684e
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      sha256: "94ef0f72b2d71bc3e700e025db3710911bd51a71cefb65cc609dd0d9a982e3c1"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shelf:
    dependency: transitive
    description:
      name: shelf
      sha256: ad29c505aee705f41a4d8963641f91ac4cee3c8fad5947e033390a7bd8180fa4
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  shelf_web_socket:
    dependency: transitive
    description:
      name: shelf_web_socket
      sha256: "073c147238594ecd0d193f3456a5fe91c4b0abbcc68bf5cd95b36c4e194ac611"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.99"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "14658ba5f669685cd3d63701d01b31ea748310f7ab854e471962670abcf57832"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  source_helper:
    dependency: transitive
    description:
      name: source_helper
      sha256: "6adebc0006c37dd63fe05bca0a929b99f06402fc95aa35bf36d67f5c06de01fd"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.4"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "53e943d4206a5e30df338fd4c6e7a077e02254531b138a15aec3bd143c1a8b3c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.0"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "73713990125a6d93122541237550ee3352a2d84baad52d375a4cad2eb9b7ce0b"
      url: "https://pub.dev"
    source: hosted
    version: "1.11.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: ba2aa5d8cc609d96bbb2899c28934f9e1af5cddbd60a827822ea467161eb54e7
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  stream_transform:
    dependency: transitive
    description:
      name: stream_transform
      sha256: "14a00e794c7c11aa145a170587321aedce29769c08d7f58b1d141da75e3b1c6f"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "556692adab6cfa87322a115640c11f13cb77b3f076ddcc5d6ae3c20242bedcde"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: a29248a84fbb7c79282b40b8c72a1209db169a2e0542bce341da992fe1bc7e84
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: "5b8a98dafc4d5c4c9c72d8b31ab2b23fc13422348d2997120294d3bac86b4ddb"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.2"
  timing:
    dependency: transitive
    description:
      name: timing
      sha256: "70a3b636575d4163c477e6de42f247a23b315ae20e86442bebe32d3cabf61c32"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.1"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  url_launcher:
    dependency: "direct main"
    description:
      name: url_launcher
      sha256: "9d06212b1362abc2f0f0d78e6f09f726608c74e3b9462e8368bb03314aa8d603"
      url: "https://pub.dev"
    source: hosted
    version: "6.3.1"
  url_launcher_android:
    dependency: transitive
    description:
      name: url_launcher_android
      sha256: "0dea215895a4d254401730ca0ba8204b29109a34a99fb06ae559a2b60988d2de"
      url: "https://pub.dev"
    source: hosted
    version: "6.3.13"
  url_launcher_ios:
    dependency: transitive
    description:
      name: url_launcher_ios
      sha256: e43b677296fadce447e987a2f519dcf5f6d1e527dc35d01ffab4fff5b8a7063e
      url: "https://pub.dev"
    source: hosted
    version: "6.3.1"
  url_launcher_linux:
    dependency: transitive
    description:
      name: url_launcher_linux
      sha256: e2b9622b4007f97f504cd64c0128309dfb978ae66adbe944125ed9e1750f06af
      url: "https://pub.dev"
    source: hosted
    version: "3.2.0"
  url_launcher_macos:
    dependency: transitive
    description:
      name: url_launcher_macos
      sha256: "769549c999acdb42b8bcfa7c43d72bf79a382ca7441ab18a808e101149daf672"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  url_launcher_platform_interface:
    dependency: transitive
    description:
      name: url_launcher_platform_interface
      sha256: "552f8a1e663569be95a8190206a38187b531910283c3e982193e4f2733f01029"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  url_launcher_web:
    dependency: transitive
    description:
      name: url_launcher_web
      sha256: "772638d3b34c779ede05ba3d38af34657a05ac55b06279ea6edd409e323dca8e"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.3"
  url_launcher_windows:
    dependency: transitive
    description:
      name: url_launcher_windows
      sha256: "44cf3aabcedde30f2dba119a9dea3b0f2672fbe6fa96e85536251d678216b3c4"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: "80b3257d1492ce4d091729e3a67a60407d227c27241d6927be0130c98e741803"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "5c5f338a667b4c644744b661f309fb8080bb94b18a7e91ef1dbd343bed00ed6d"
      url: "https://pub.dev"
    source: hosted
    version: "14.2.5"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "3d2ad6751b3c16cf07c7fca317a1413b3f26530319181b37e3b9039b84fc01d8"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  web:
    dependency: transitive
    description:
      name: web
      sha256: cd3543bd5798f6ad290ea73d210f423502e71900302dde696f8bff84bf89a1cb
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  web_socket:
    dependency: transitive
    description:
      name: web_socket
      sha256: "3c12d96c0c9a4eec095246debcea7b86c0324f22df69893d538fcc6f1b8cce83"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.6"
  web_socket_channel:
    dependency: transitive
    description:
      name: web_socket_channel
      sha256: "9f187088ed104edd8662ca07af4b124465893caf063ba29758f97af57e61da8f"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: "7a3f37b05d989967cdddcbb571f1ea834867ae2faa29725fd085180e0883aa15"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: "75769501ea3489fca56601ff33454fe45507ea3bfb014161abc3b43ae25989d5"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
sdks:
  dart: ">=3.5.3 <4.0.0"
  flutter: ">=3.24.0"

```

# pubspec.yaml

```yaml
name: Lists
description: "A modern list app with multiple lists, category filtering, and price tracking in EUR/USD. Features smooth animations, dark/light themes, and drag-and-drop reordering."
publish_to: 'none'
version: 0.1.0

environment:
  sdk: ^3.5.3

dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.6
  flutter_slidable: ^3.1.0
  path_provider: ^2.0.0
  url_launcher: ^6.3.1
  firebase_core: ^3.6.0
  cloud_firestore: ^5.4.4
  firebase_auth: ^5.3.1
  shared_preferences: ^2.3.2

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0
  hive_generator: ^2.0.1
  build_runner: ^2.1.11

flutter:
  uses-material-design: true

```

# README.md

```md
# Modern Lists App

A feature-rich Flutter application for managing lists with real-time synchronization, multi-currency support, and a modern user interface.

![Flutter Version](https://img.shields.io/badge/Flutter-3.5.3-blue.svg)
![Firebase](https://img.shields.io/badge/Firebase-Enabled-orange.svg)
![License](https://img.shields.io/badge/License-MIT-green.svg)

## ✨ Features

- **Multiple Lists**: Create and manage multiple lists
- **Real-time Sync**: All changes are synchronized in real-time using Firebase
- **Multi-Currency Support**: Toggle between EUR (€) and USD ($) with automatic conversion
- **Category Filtering**: Organize items by categories for better overview
- **Drag & Drop**: Intuitive drag-and-drop reordering of items
- **Share Lists**: Collaborate by sharing lists with other users
- **Dark/Light Theme**: Automatic theme switching based on system preferences
- **Animated UI**: Smooth animations and transitions throughout the app
- **URL Support**: Add and open product URLs directly from items
- **Offline Support**: Local caching for offline access

## 🚀 Getting Started

### Prerequisites

- Flutter (3.5.3 or higher)
- Dart SDK
- Firebase account
- Android Studio / VS Code

### Installation

1. Clone the repository
\`\`\`bash
git clone https://github.com/yourusername/shopping-lists-app.git
\`\`\`

2. Install dependencies
\`\`\`bash
flutter pub get
\`\`\`

3. Configure Firebase
   - Create a new Firebase project
   - Add Android & iOS apps in Firebase console
   - Download and replace the `google-services.json` and `GoogleService-Info.plist`
   - Enable Email/Password authentication in Firebase console
   - Set up Cloud Firestore database

4. Run the app
\`\`\`bash
flutter run
\`\`\`

## 🏗️ Architecture

The app follows a clean architecture pattern with:

- **Firebase Service**: Handles all Firebase interactions
- **Local Database**: Manages local caching and offline support
- **UI Components**: Reusable widgets with consistent styling
- **State Management**: Stream-based real-time updates
- **Animations**: Custom animation controllers for smooth transitions

## 🛠️ Built With

- **Flutter**: UI framework
- **Firebase**:
  - Authentication
  - Cloud Firestore
  - Real-time Database
- **Provider**: State management
- **flutter_slidable**: Sliding actions
- **url_launcher**: External URL handling

## 📱 Screenshots

Screenshots coming soon

## 🤝 Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the Project
2. Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3. Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the Branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 👤 Author

Your Name
- GitHub: [@YourInternationalMate](https://github.com/YourInternationalMate)

## 🙏 Acknowledgments

- [Flutter Team](https://flutter.dev)
- [Firebase](https://firebase.google.com)
- All contributors who help improve this project

```

